10章 列挙体とパターン

列挙型(enumerations)もしくはenum
→名前付きの定数の集合を値とする独自の型

Rustの列挙型
→様々な型のデータを持つことが可能
→→共用体(union)に近い

ある値が複数のもののいずれかしか取らないときに有効
→代償はパターンマッチを使ってデータを安全にアクセスしなければならないこと
→→Rustのパターンはデータに対する正規表現のようなもの

10.1 列挙型

C styleの列挙型

enum Name {
    variant1,
    variant2,
    ...
}

取りうる値
→ヴァリアント(variant)もしくは構成子(constructors)と呼ぶ

enumerationsやvariantをimportすることができる
→variantをインポートしておけばhoge::varをvarとして使える
→→明示的でなくなるのでしないほうが良いが可読性とのトレードオフで

現在のmoduleに宣言されている列挙型のvariantをimportするにはselfインポートを使う

メモリ上では整数として表現される
→もちろんどの整数値を使うべきか指定できる
→未指定の場合0から順番に値を決める
→→デフォルトでは値を表現できる最小の型を使う

#[repr]属性を付加することでメモリ上の表現を指定することができる
→詳しくは 21章 unsafeなコード

列挙型から整数型へのキャストは許されている(as演算子を用いる)
→整数型から列挙型へのキャストはenum宣言内の値になる保証ができないので不可
→→自分でチェックしながらmatchで変換することはできる
→→もしくはenum_primitiveクレート(自動生成マクロ)を使ってもよい

構造体と同様に#[derive(Copy, Clone,...)]で明示的に要求すると機能をコンパイラが実装

構造体と同様メソッドを持つこともできる(impl)

10.1.1 データを保持する列挙体

タプル型ヴァリアント(tuple variants):
列挙型のvariantのうち引数を持つもの

→tupleの時と同じでこの書き方(コンストラクタ)が新たなEnumretion値を作るための関数になる

構造体型ヴァリアント(struct variants):
名前付きフィールドを持つヴァリアント

variant ⟷  unit型構造体
tuple variant ⟷  tuple structure
struct variant ⟷  named field

１つの列挙体にこれらが混ざっても構わない

10.1.2 列挙型のメモリ上での表現

メモリ上でのデータを持つ列挙体
→タグ(小さい整数)と最大のヴァリアントが全てのfieldを保持できるサイズのメモリで構成される
→→タグfieldはRustが内部的に用いる
→→→メモリの空きはアライメント用のパディング

最適化の余地を残すために列挙型のレイアウトは何も保証されない
→例えばタグの除去を行う最適化は実装済

10.1.3 列挙体を用いたリッチなデータ構造

列挙型はツリー状のデータ構造を実装するのに適している

列挙型の各ヴァリアントはメモリの上では同じサイズ
→HashMapの様に大きい領域が必要な場合Boxに入れれば1ワードに抑えられる

C++だとclassの中にTagのenumを用意してDataのunionを用意して...と難解になる

10.1.4 ジェネリック列挙型

列挙型をジェネリックにすることができる

enum Option<T> {
    None,
    Some(T)
}

この場合型TがBoxなどのスマートポインタ型だった場合、Option<T>のTagフィールドは削除できる
→0: None, otherwise: Some(T) を表す(1wordで十分)
→→Nullを取りうるポインタを表すのにBox<T>とNoneをもつ列挙型は有用

データ構造をRustで書けるようになるには少し練習が必要
→図を描き、メモリ上にどのように配置したいかを考えてみると良い
→→長方形は構造体かタプル、矢印はBoxなどのスマートポインタ

列挙型の一番の問題:
警告なしに値のフィールドにアクセスできない
→フィールドの値の実際の有無に関わらない

10.2 パターン

match式
→パターンマッチを行い値を消費し式を生成
→→左から右への単純なスキャンのように動作

パターンに単純な識別子がある
→パターン以降ローカル変数になる

パターンに入っていた値はコピーまたは移動される

パターンマッチは列挙型と連動して操作
→内部データのテストすら可能
→→詳細はp.215の表10-1で確認

10.2.1 パターン内のリテラル、変数、ワイルドカード

Cのswicth文のようなもの
→整数値を使ったmatch
→→その他のリテラルもパターンとして使える
→→→変数を置いておくと全てのパターンにマッチする。値に興味がない時はアンダースコアで受ける
→→→→ワイルドカードパターン

patternに識別子を置くと新しい変数ができてしまう
→既存の変数を使えない
→→例えばSome()の中身を見たければif文で制御すれば良い

10.2.2 タプルと構造体パターン

タプルパターンはタプルにマッチする
→複数のデータを一度のmatchで扱いたい時に使う

構造体パターン
→中括弧を使う。それぞれのfieldに対してはサブパターンを書く
→→fieldの両方に新規変数を与える時、省略形がサポートされている such as Point{x, y}
→→→マッチ時にfieldを..で省略できる

10.2.3 参照パターン

refパターン
→マッチした値の一部を借用

match式で移動が起こる場合、移動が起こってしまう時がある
→refキーワードをつけてマッチさせるとパターン適合時に借用する
→→ref mutで可変参照を借用することも可能 

&パターン
→参照にマッチする
→→ポインタを参照解決してマッチする

パターンと式は逆の操作
→&は式中で参照を作りパターン中で参照にマッチする
→→変数で落とした場合、コピー型の場合はコピーされる
→→非コピー型の値はrefパターンで参照を借用するとよい

参照へのマッチ
→生存期間が強制される

Some(&hoge)型をSome(&hoge)でマッチするとhoge型で扱える(参照する)

10.2.4 複数の可能性へのマッチ

|を使って複数のパターンを1つの分岐にまとめることができる

...を用いて様々な範囲の値にマッチさせることができる
→最初の値と最後の値を含む(閉区間)

10.2.5 パターンガード

ifキーワードを用いてmatchの分岐にガード(guard)
→ガード式の評価がtrueの時のみマッチ
→→パターンが値を移動するときには使えない(refを使えば良い)

10.2.6 ＠パターン

x @ pattern 
→マッチするとそれぞれの部品にわけずひとつの変数xに値全体をコピーまたは移動する

10.2.7 パターンが使える場所





































































































































































