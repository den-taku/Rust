8章クレートとモジュール

クレートとモジュール
→プログラムを構造化

ドキュメントの書き方、テストの仕方、コンパイラエラー制御、依存関係とバージョン管理、OSLibraryなどなど

8.1 クレート

Rustプログラムはクレートで構成される
→全てのソースコードやテスト、設定やツールなど全てが収められる

ライブラリはクレートとして配布されている
→依存関係を見たければ cargo build --verbose

extern crate ...;
→...が外部ライブラリであることをコンパイラに宣言

[dependencies]
→そのプロジェクトが使うクレートを示す

クレートはcrate.io(http://crate.io/)にある
→個々のクレートのページにはdocやsrcへのリンクと設定行が提供されている

クレートのダウンロード→Cargo.tomlからさらにクレートをダウンロード→全てのクレートをコンパイル

ライブラリのコンパイルには --crate-type libを用いる
→main()関数を探さず.rlibファイルを作る

本体のプログラムのコンパイルには --crate-type binを用いる
→結果はターゲット環境のバイナリ実行ファイル

rustcコマンドを実行する時に--externオプションでライブラリファイル名を指定
→rustcにコンパイル済みクレートの場所を教える
→→.rlibファイルは最終的な実行ファイルに静的にリンクする

cargo buildには様々なオプションがある
→例えば--releaseは最適化するがコンパイルに時間がかかる。少し粗い

8.1.1 ビルドプロファイル

Cargo.tomlファイルの設定でcargoが生成するrustcのコマンドラインを制御できる

-command line-          -section in Cargo.toml-            
cargo build             [profile.dev]
cargo build --release   [profile.release]
cargo test              [profile.test]

プロファイラ:
プログラムのどこでCPU時間を使っているかを測定するツール
→良いデータを取るには最適化を行いデバッグシンボルがつくようにコンパイル
→→ただしこれらはそれぞれリリースビルド、デバッグビルドでしか有効でない
→→→debugはrustcに-gオプションをつけるかどうか制御

様々な設定方法がCargo (http://doc.crates.io/manifest.html)のdocに

8.2 モジュール

モジュール(module):
Rustの名前空間。プログラムやライブラリの関数、型、定数などのコンテナ

mod name {
...
}

クレート→プロジェクト間のコード共有
モジュール→プロジェクト内部のコード構造化

モジュールはアイテムの集合体
→アイテム:名前のついた機能(構造体や関数など)

pubキーワード
→モジュールの外からアクセスできるようにアイテムをパブリックにする
→→pubがついていないものは全てプライベートとなる

moduleはネストにすることができる

mod parent {
    pub mod child {
    ...
    }
}

このようにmoduleの階層全体と大量のコードからなるプログラム全体を１つにすることもできる
→ただし別のスマートな方法が用意されている

8.2.1 モジュールの複数ファイルへの分割

mod spores;
→このようにもモジュールは書ける
→sporesモジュールがspores.rsに入っていることをコンパイラに知らせる
→spores.rsにはモジュールを構成するアイテムだけが書かれる

２つの違いはコードが置かれる場所だけ

モジュールをディレクトリで構成することもできる
→mod spores;宣言文を見るとspores.rsとspores/mod.rsの両方をチェックする
→→両方ない、または両方あるときはエラーになる

fern_sim/
    Cargo.toml
    srs/
        main.rs ← pub mod plant_structures;
        spores.rs
        plant_structures/
            mod.rs
            leaves.rs
            roots.rs
            sterms.rs

// in plant_suructures/mod.rs
pub mod roots;
pub mod sterms;
pub mod leaves;

8.2.2 パスとインポート

::演算子
→モジュールの機能にアクセスするために用いる
→→プロジェクト内の任意の標準ライブラリの機能を絶対パスで参照可能
→→→ ::std::mem::swap()とか(::stdはトップレベルモジュール)

use宣言:
使いたい機能をimportする
→宣言しているblockもしくはmodule全体で局所的なエイリアスとして使えるようになる
→use std::mem; で memを使えるようになる
→→一般的にはtypeやtraitやmoduleをimportして相対パスを用いる方が良いスタイル

moduleは親moduleの名前空間を自動的に引き継がない
→個々のmoduleは白紙状態から始まるので利用する名前をインポートする必要がある

super:親moduleのエイリアス
self:現在のmoduleのエイリアス
→相対パスを指定できる
→親moduleのプライベートアイテムにはそれぞれ個別にimportすればアクセスできる
→→use super::*;ではpublic itemしかimportされない

moduleとfileは同じではないが類似関係がある
→useはlnで作るリンクのようなエイリアスを作る
→selfとsuperはスペシャルディレクトリ.と..に似ている
→extern crateは別のcrateのroot moduleを自分のprojectに接ぎ木する(マウントに似ている)

8.2.3 標準のプレリュード





















































































