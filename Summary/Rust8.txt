8章クレートとモジュール

クレートとモジュール
→プログラムを構造化

ドキュメントの書き方、テストの仕方、コンパイラエラー制御、依存関係とバージョン管理、OSLibraryなどなど

8.1 クレート

Rustプログラムはクレートで構成される
→全てのソースコードやテスト、設定やツールなど全てが収められる

ライブラリはクレートとして配布されている
→依存関係を見たければ cargo build --verbose

extern crate ...;
→...が外部ライブラリであることをコンパイラに宣言

[dependencies]
→そのプロジェクトが使うクレートを示す

クレートはcrate.io(http://crate.io/)にある
→個々のクレートのページにはdocやsrcへのリンクと設定行が提供されている

クレートのダウンロード→Cargo.tomlからさらにクレートをダウンロード→全てのクレートをコンパイル

ライブラリのコンパイルには --crate-type libを用いる
→main()関数を探さず.rlibファイルを作る

本体のプログラムのコンパイルには --crate-type binを用いる
→結果はターゲット環境のバイナリ実行ファイル

rustcコマンドを実行する時に--externオプションでライブラリファイル名を指定
→rustcにコンパイル済みクレートの場所を教える
→→.rlibファイルは最終的な実行ファイルに静的にリンクする

cargo buildには様々なオプションがある
→例えば--releaseは最適化するがコンパイルに時間がかかる。少し粗い

8.1.1 ビルドプロファイル

Cargo.tomlファイルの設定でcargoが生成するrustcのコマンドラインを制御できる

-command line-          -section in Cargo.toml-            
cargo build             [profile.dev]
cargo build --release   [profile.release]
cargo test              [profile.test]

プロファイラ:
プログラムのどこでCPU時間を使っているかを測定するツール
→良いデータを取るには最適化を行いデバッグシンボルがつくようにコンパイル
→→ただしこれらはそれぞれリリースビルド、デバッグビルドでしか有効でない
→→→debugはrustcに-gオプションをつけるかどうか制御

様々な設定方法がCargo (http://doc.crates.io/manifest.html)のdocに

8.2 モジュール

モジュール(module):
Rustの名前空間。プログラムやライブラリの関数、型、定数などのコンテナ

mod name {
...
}

クレート→プロジェクト間のコード共有
モジュール→プロジェクト内部のコード構造化

モジュールはアイテムの集合体
→アイテム:名前のついた機能(構造体や関数など)

pubキーワード
→モジュールの外からアクセスできるようにアイテムをパブリックにする
→→pubがついていないものは全てプライベートとなる

moduleはネストにすることができる

mod parent {
    pub mod child {
    ...
    }
}

このようにmoduleの階層全体と大量のコードからなるプログラム全体を１つにすることもできる
→ただし別のスマートな方法が用意されている

8.2.1 モジュールの複数ファイルへの分割

mod spores;
→このようにもモジュールは書ける
→sporesモジュールがspores.rsに入っていることをコンパイラに知らせる
→spores.rsにはモジュールを構成するアイテムだけが書かれる

２つの違いはコードが置かれる場所だけ

モジュールをディレクトリで構成することもできる
→mod spores;宣言文を見るとspores.rsとspores/mod.rsの両方をチェックする
→→両方ない、または両方あるときはエラーになる

fern_sim/
    Cargo.toml
    srs/
        main.rs ← pub mod plant_structures;
        spores.rs
        plant_structures/
            mod.rs
            leaves.rs
            roots.rs
            sterms.rs

// in plant_suructures/mod.rs
pub mod roots;
pub mod sterms;
pub mod leaves;

8.2.2 パスとインポート

::演算子
→モジュールの機能にアクセスするために用いる
→→プロジェクト内の任意の標準ライブラリの機能を絶対パスで参照可能
→→→ ::std::mem::swap()とか(::stdはトップレベルモジュール)

use宣言:
使いたい機能をimportする
→宣言しているblockもしくはmodule全体で局所的なエイリアスとして使えるようになる
→use std::mem; で memを使えるようになる
→→一般的にはtypeやtraitやmoduleをimportして相対パスを用いる方が良いスタイル

moduleは親moduleの名前空間を自動的に引き継がない
→個々のmoduleは白紙状態から始まるので利用する名前をインポートする必要がある
→同一crate内にネストしても白紙からスタート

super:親moduleのエイリアス
self:現在のmoduleのエイリアス
→相対パスを指定できる
→親moduleのプライベートアイテムにはそれぞれ個別にimportすればアクセスできる
→→use super::*;ではpublic itemしかimportされない

moduleとfileは同じではないが類似関係がある
→useはlnで作るリンクのようなエイリアスを作る
→selfとsuperはスペシャルディレクトリ.と..に似ている
→extern crateは別のcrateのroot moduleを自分のprojectに接ぎ木する(マウントに似ている)

8.2.3 標準のプレリュード

namaspeceは「完全に」白紙というわけではない

stdlibは自動的に全てのprojectにlinkされる
→extern crate std;が暗黙のうちにされていると思えば良い

さらにVecやResultなどのよく使われるものは標準のpreludeに含まれている
→自動的にimportされる
→use std::prelude::v1::*;のようなimport宣言があるかのように振る舞う

標準prelude:
数ダースの広く使われているtraitやtypeが含まれている
→ただしstdは含まれていないのでuse std;は明示的に
→→普通はstdの特定の利用する機能だけimport

preludeという名前のmoduleを提供するライブラリ
→自動的にはインポートされない。prelude::*でimportしてほしいという慣習でしかない

8.2.4 Rustの構成要素:アイテム

moduleはitemで構成される
→この言語の主要機能は全てitemだと考えて良い

fnction
→既

type

→ユーザ定義型はキーワードstruct、enum、traitを用いて導入する(それぞれ各章で)
→→構造体のフィールドはprivateフィールドでもその構造体がdefされたmodule内部からはaccessable
→→moduleの外からはpublicフィールドだけがアクセス可能

→アクセス制御をclassでなくmoduleにしたことで楽に設計できる
→→複数の型を1つのmoduleに定義できるので

型alias

→typeキーワードを用いて古い型に新しい名前を宣言できる

implブロック

→型にメソッドを付加する(詳しくは9章)
→implブロック全体をpubにすることはできない
→→個々のメソッドを外部から使うにはメソッドごとpubにする
→→privateメソッドは宣言されているmodule全体から見える

定数

→constキーワードを用いる
→必要ならpubがつき、必ず型指定する点がletと異なる
→→慣用的に全て大文字でかきアンダースコアで区切る
→→→値を使う全ての場所に値がコンパイル時に埋め込まれる
→→→マジックナンバーやマジック文字列には定数を使う
→→→→ummutable

→staticキーワードがstatic itemを導入
→→定数とほぼ同じ
→→→プログラム実行開始前に用意され終了するまで生き残る変数
→→→定数値への参照を借用する必要があるなら(データが大きい等)
→mutableだが排他的なアクセスを強制する方法がないので安全なコードからは使えない

→Rustではグローバル可変は推奨されない(詳しくは19.3.11 グローバル変数)

module

→moduleはsubmoduleから構成されpublicとprivateがある

import

→use宣言やextern crate宣言もアイテム
→→publicにできる(別名をつけるだけ)
→→→pub use self::leaves::LeafとするとLeafがpublic itemになる

externブロック

→他の言語で書かれた一連のコードを宣言してRustから呼び出せるようにする(21章で)

Rustでは使われていないitemがあると警告を出力する
→他のcrateで使う場合、itemの外側の全てのmoduleをpublicにする必要がある

8.3 プログラムからライブラリへ

既存のプロジェクトを２つの部分に分離する
・共通コードを全て納めたlibrary crate
・コマンドラインプログラムのためだけに必要なコードを収めた実行ファイル

ライブラリへの変更方(fern)
・src/main.rsをsrc/lib.rsに変更
・src/main.rs中のpublicにすべき機能にpubキーワードを付加
・main関数を一時ファイルに避けておく
→Cargo.tomlを変更する必要がない(defaultで最低限の動作を保証)

src/lib.rsがライブラリのroot moduleを構成する
→このライブラリを用いる他のcrateはこれのpublic itemしかアクセスできない












































































