21章 unsafeなコード

Rustの推論では安全と認識できないが有用なテクニックは存在する

unsafeなコード
→プログラマの責任で安全性を担保する
→→型チェック、生存期間チェック、インデックスの境界チェックなどの通常のチェックは行われる

unsafeブロックは通常の安全なRustコードとの境界を明確にする

関数をunsafeにすることもできる
→呼び出し元に対して未定義動作を防ぐためのルールの警告ができる

rawポインタを使えば無制限にメモリアクセスできる

Rustの外部関数インターフェイスを使うと他の言語で書かれたライブラリを使用できる

unsafeトレイトはそれぞれの実装が従わなくてはならない制約を課す

21.1 何に対してunsafeなのか

unsafe機能はなんらかの契約(contract)を課す
→未定義動作を避けるために従わなければならないルール

典型的には契約はドキュメントに記述されるだけでコンパイラは知ることができない

未定義動作が起きたとき、Rustは結果を予測するのをやめる

unsafeブロックやunsafe関数をかく
→プログラマが追加されたルールのことを了承しているということ

21.2 unsafeなブロック

unsafeブロック
→通常のRustのブロックの前にキーワードunsafeをつけたもの

・unsafe関数を呼び出すことができる
・rawポインタを参照解決できる(メモリアクセスはunsafe中でしかできない)
・可変static変数にアクセスできる
・外部関数インターフェイスを通じて関数や変数にアクセスできる

unsafeの利点:
安全性を保証できないコードにプログラマの注意を引くことができる

本当にunsafeを使わないとボトルネックになるのか自問することができる

21.2.1 例:効率的なASCII文字列型

ニュータイプ(newtype):
内容に対するルールをモジュール内だけでラッパしたタイプ
→機械語のレベルではニュータイプと元のタイプは同一の表現

21.3 unsafe関数

冒頭にunsafeキーワードがつく

unsafeブロックに入る前に発生したバグによって契約が破られることがある
→ブロックで提供される値を提供するコードにも依存する

契約を破ったことの結果はunsafeブロック内で現れるとは限らない

unsafeキーワードを書く
→言語の安全性チェックの利点を享受できなくなるということ

実装にunsafeを利用する場合でも契約が必要ないインターフェイスを作るべき

21.4 unsafeブロックかunsafe関数か？





























































































