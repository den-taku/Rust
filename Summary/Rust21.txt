21章 unsafeなコード

Rustの推論では安全と認識できないが有用なテクニックは存在する

unsafeなコード
→プログラマの責任で安全性を担保する
→→型チェック、生存期間チェック、インデックスの境界チェックなどの通常のチェックは行われる

unsafeブロックは通常の安全なRustコードとの境界を明確にする

関数をunsafeにすることもできる
→呼び出し元に対して未定義動作を防ぐためのルールの警告ができる

rawポインタを使えば無制限にメモリアクセスできる

Rustの外部関数インターフェイスを使うと他の言語で書かれたライブラリを使用できる

unsafeトレイトはそれぞれの実装が従わなくてはならない制約を課す

21.1 何に対してunsafeなのか

unsafe機能はなんらかの契約(contract)を課す
→未定義動作を避けるために従わなければならないルール

典型的には契約はドキュメントに記述されるだけでコンパイラは知ることができない

未定義動作が起きたとき、Rustは結果を予測するのをやめる

unsafeブロックやunsafe関数をかく
→プログラマが追加されたルールのことを了承しているということ

21.2 unsafeなブロック

unsafeブロック
→通常のRustのブロックの前にキーワードunsafeをつけたもの

・unsafe関数を呼び出すことができる
・rawポインタを参照解決できる(メモリアクセスはunsafe中でしかできない)
・可変static変数にアクセスできる
・外部関数インターフェイスを通じて関数や変数にアクセスできる

unsafeの利点:
安全性を保証できないコードにプログラマの注意を引くことができる

本当にunsafeを使わないとボトルネックになるのか自問することができる

21.2.1 例:効率的なASCII文字列型

ニュータイプ(newtype):
内容に対するルールをモジュール内だけでラッパしたタイプ
→機械語のレベルではニュータイプと元のタイプは同一の表現

21.3 unsafe関数

冒頭にunsafeキーワードがつく

unsafeブロックに入る前に発生したバグによって契約が破られることがある
→ブロックで提供される値を提供するコードにも依存する

契約を破ったことの結果はunsafeブロック内で現れるとは限らない

unsafeキーワードを書く
→言語の安全性チェックの利点を享受できなくなるということ

実装にunsafeを利用する場合でも契約が必要ないインターフェイスを作るべき

21.4 unsafeブロックかunsafe関数か？

unsafeブロックを使うべきか、それとも関数丸ごとunsafeにするべきか?

コンパイルは通るが未定義動作が起きるような使い方ができてしまう
→unsafe関数にして契約として示す

そうではない
→関数は安全なのでunsafeにすべきではない

重要なのは契約があるかどうか

21.5 未定義動作

未定義動作:
コードが決して起こさないとRustが固く信じる挙動

コンパイラは言語の変換器
→RustコンパイラはRustプログラムを等価な機械語プログラムに変換する

プログラムが等価
→実行時に同じ観測的挙動を示す

言語の基本機能が設計通りに動くことを信じられない
→ある変換によってプログラムの意味が変化するかどうかを判断できない

Rustに置ける正しく振る舞うプログラムのルール

・プログラムは初期化されていないメモリを読んではならない
・プログラムは無効な基本型を作ってはならない
  ・nullをさす参照やBox
  ・0でも1でもないbool値
  ・無効な判断値を持つenum値
  ・有効でなくサロゲートでもないUnicodeコードポイントをさすchar値
  ・整形式でないUTF-8を持つstr値
・5章で説明された山椒に関するルールを守る
  ・参照は参照先よりも長生きしてはならない
  ・共有アクセスは読み出ししかできない
  ・可変アクセスは排他的でなくてはならない
・プログラムはnullポインタ、不適切にアラインされたポインタ、解放されたポインタを参照解決してはならない
・ポインタが関連づけられたメモリ確保領域外をそのポインタでアクセスしてはならない
・データ競合を起こしてはならない
・外部言語インターフェイスを通じて他の言語から行われた呼び出しのスタックを巻き戻してはならない
・標準ライブラリ関数の課す契約に従わなければならない

unsafeを使わないコードはコンパイルが通ればこれらのルールに従っていることが保証される

21.6 unsafeトレイト

unsafeトレイト:
Rustがチェックすることは強要できないが契約が存在するトレイト

型変数の制約にunsafeトレイトを指定する関数
→それ自身unsafeな機能を使いunsafeトレイトの契約に依存してunsafeな機能の契約を満たしていることが多い

SendやSync、Zeroableなど(これらはマーカトレイト)
→Rustはこれらが何を意味しているかわからない

unsafeトレイトは通常の安全なトレイトが正しく実装されていることに依存してはいけない

21.7 rawポインタ



























































































