21章 unsafeなコード

Rustの推論では安全と認識できないが有用なテクニックは存在する

unsafeなコード
→プログラマの責任で安全性を担保する
→→型チェック、生存期間チェック、インデックスの境界チェックなどの通常のチェックは行われる

unsafeブロックは通常の安全なRustコードとの境界を明確にする

関数をunsafeにすることもできる
→呼び出し元に対して未定義動作を防ぐためのルールの警告ができる

rawポインタを使えば無制限にメモリアクセスできる

Rustの外部関数インターフェイスを使うと他の言語で書かれたライブラリを使用できる

unsafeトレイトはそれぞれの実装が従わなくてはならない制約を課す

21.1 何に対してunsafeなのか

unsafe機能はなんらかの契約(contract)を課す
→未定義動作を避けるために従わなければならないルール

典型的には契約はドキュメントに記述されるだけでコンパイラは知ることができない

未定義動作が起きたとき、Rustは結果を予測するのをやめる

unsafeブロックやunsafe関数をかく
→プログラマが追加されたルールのことを了承しているということ

21.2 unsafeなブロック

unsafeブロック
→通常のRustのブロックの前にキーワードunsafeをつけたもの

・unsafe関数を呼び出すことができる
・rawポインタを参照解決できる(メモリアクセスはunsafe中でしかできない)
・可変static変数にアクセスできる
・外部関数インターフェイスを通じて関数や変数にアクセスできる

unsafeの利点:
安全性を保証できないコードにプログラマの注意を引くことができる

本当にunsafeを使わないとボトルネックになるのか自問することができる

21.2.1 例:効率的なASCII文字列型

ニュータイプ(newtype):
内容に対するルールをモジュール内だけでラッパしたタイプ
→機械語のレベルではニュータイプと元のタイプは同一の表現

21.3 unsafe関数

冒頭にunsafeキーワードがつく

unsafeブロックに入る前に発生したバグによって契約が破られることがある
→ブロックで提供される値を提供するコードにも依存する

契約を破ったことの結果はunsafeブロック内で現れるとは限らない

unsafeキーワードを書く
→言語の安全性チェックの利点を享受できなくなるということ

実装にunsafeを利用する場合でも契約が必要ないインターフェイスを作るべき

21.4 unsafeブロックかunsafe関数か？

unsafeブロックを使うべきか、それとも関数丸ごとunsafeにするべきか?

コンパイルは通るが未定義動作が起きるような使い方ができてしまう
→unsafe関数にして契約として示す

そうではない
→関数は安全なのでunsafeにすべきではない

重要なのは契約があるかどうか

21.5 未定義動作

未定義動作:
コードが決して起こさないとRustが固く信じる挙動

コンパイラは言語の変換器
→RustコンパイラはRustプログラムを等価な機械語プログラムに変換する

プログラムが等価
→実行時に同じ観測的挙動を示す

言語の基本機能が設計通りに動くことを信じられない
→ある変換によってプログラムの意味が変化するかどうかを判断できない

Rustに置ける正しく振る舞うプログラムのルール

・プログラムは初期化されていないメモリを読んではならない
・プログラムは無効な基本型を作ってはならない
  ・nullをさす参照やBox
  ・0でも1でもないbool値
  ・無効な判断値を持つenum値
  ・有効でなくサロゲートでもないUnicodeコードポイントをさすchar値
  ・整形式でないUTF-8を持つstr値
・5章で説明された山椒に関するルールを守る
  ・参照は参照先よりも長生きしてはならない
  ・共有アクセスは読み出ししかできない
  ・可変アクセスは排他的でなくてはならない
・プログラムはnullポインタ、不適切にアラインされたポインタ、解放されたポインタを参照解決してはならない
・ポインタが関連づけられたメモリ確保領域外をそのポインタでアクセスしてはならない
・データ競合を起こしてはならない
・外部言語インターフェイスを通じて他の言語から行われた呼び出しのスタックを巻き戻してはならない
・標準ライブラリ関数の課す契約に従わなければならない

unsafeを使わないコードはコンパイルが通ればこれらのルールに従っていることが保証される

21.6 unsafeトレイト

unsafeトレイト:
Rustがチェックすることは強要できないが契約が存在するトレイト

型変数の制約にunsafeトレイトを指定する関数
→それ自身unsafeな機能を使いunsafeトレイトの契約に依存してunsafeな機能の契約を満たしていることが多い

SendやSync、Zeroableなど(これらはマーカトレイト)
→Rustはこれらが何を意味しているかわからない

unsafeトレイトは通常の安全なトレイトが正しく実装されていることに依存してはいけない

21.7 rawポインタ

rawポインタ:
制約のないポインタ
→非常に柔軟なので安全に使われているかRustコンパイラが判断できない
→→参照解決できるのはunsafeブロックの中だけ

rawポインタは本質的にCとC++のポインタと同じ

*mut T:
Tへのrawポインタで参照先の変更を許す

*const T:
Tへのrawポインタで参照先の読み出しのみを許す

ただの*T型はない

rawポインタは参照から変換して作ることができる
*演算子で参照解決することができる

rawポインタはnullであり得る

unsizedな型に対するrawポインタはファットポインタ

rawポインタは自動的な参照解決はされないので明示的にする
→.演算子で暗黙参照解決されない
→Derefを実装していないので参照解決型変換は適用されない
→フォーマットトレイトも参照を自動的には辿らない

rawポインタ自体はアドレス値自体として扱われる

rawポインタに+演算子は利用できない
→offsetやwrapping_offsetメソッドを使ってポインタ演算行うことはできる

-演算子でポインタ間の距離を計算する標準の演算子はない
→自分で実装することはできる

参照からrawポインタへの暗黙のキャストは行われる
rawポインタから参照への暗黙のキャストは行われない

as演算子でほとんど全ての参照からrawポインタやrawポインタ間での変換ができる
→複雑な変換は段階的に変換する必要がある
→→無制限の生存期間を持つので注意

as_ptr()、as_mut_ptr():
内容物へのrawポインタを返す

into_raw()、from_raw():
Box、Ac、Arcなどの所有するポインタ型とrawポインタ間で変換する

参照とは異なりrawポインタはSendでもSyncでもない
→どこにあろうとunsafeなのは参照解決する際

21.7.1 rawポインタを安全に参照解決するには

rawポインタを安全に使うためのガイドライン

・nullポインタやダングリングポインタを参照解決するのは未定義動作
・参照対象の型として適切にアラインされていないポインタは未定義
・rawポインタを参照解決して得た値から参照を借用して良いのは参照の安全性のルールを守っている時だけ
・rawポインタに対してoffsetは元のポインタの領域内に収まる時だけ。アドレスの整数演算も
・rawポインタの参照先への代入は型の不変条件を守らなければならない

これらは原則に過ぎないが大体はこれに従えば安全

21.7.2 例:RefWithFlag

RefWithFlag<'a, T>を実装する
→&'a Tとboolの2つの値をタプル(&'a T, bool)のように保持するが1wordしか使用しない
→→多くの型がメモリ上の偶数アドレスにしか配置できないことを利用している

PhantomData型
→ゼロサイズの型
→→今回のコードでは生存期間を知らせるために必要

21.7.3 ヌルとなり得るポインタ

rawポインタのヌル値
→0x00をさす
→std::ptr::null<T>、std::ptr_null_mut<T>はそれぞれのヌルポインタを返す

is_nullメソッドまたはas_refメソッド・as_mutメソッドでヌルチェックする

as_ref():
*const Tポインタを取りOption<&'a T>を返す。ヌルはNone

as_mut():
*mut Tポインタを取りOptons<&'a mut T>を返す

21.7.4 型のサイズとアラインメント

Sized型の値
→メモリ上に一定のバイト数を保持しアライメント値の倍数のアドレスに配置される
→→アラインメント値は計算機アーキテクチャによって定まる
→→→アラインメントは常に2の冪乗

std::mem::size_of::<T>():
Tのバイト数を返す

std::mem::align_of::<T>():
Tのアライメント値を返す

unsized型はサイズとアラインメントが個々の値に依存する
→std::mem::size_of_val、std::mem::align_of_valで値のサイズとアラインメントを返す

21.7.5 ポインタ演算

配列、スライス、ベクタ
→sizeバイトを占めるように一定の間隔で設置されている
→→i番目の要素はi * sizeバイト目から始まる

配列が使用しているメモリ領域の次のバイトを指すポインタを作ることは許される
→参照解決してはいけない
→→それよりも先や開始点以前を指すポインタは作るだけで未定義動作
→→→wrapping_offsetメソッドを使えば境界を超えたポインタを得れる

21.7.6 メモリに移動、メモリから移動

メモリを管理する型を実装する
→メモリのどの部分が生きている値を指していてどこが未初期化かを管理する必要がある

ベクタがヒープ上の値などを保持する場合、中身までは連続したメモリ領域にあるとは限らない

初期化済みの値の定義
→生きているものとして扱われているかどうか

std::ptr::read(src):
srcが指す場所から値を移動し呼び出し元に所有権を移動する
→src仮引数はT:Sizedに対するrawポインタ*const T

std::ptr::write(dest, value):
destが指す場所にvalueを移動する
→deat仮引数はT:Sizedに対するrawポインタ*mut T、valueはTの値

これらの操作は安全なポインタ型では実装できない

これらはいずれも自由関数(rawポインタのメソッドではない)

std::ptr::copy(src, dst, count):
srcから始まるメモリ領域にあるcount個の配列をdstに移動する
→src: *const T、dst: *mut Tでcount: usizeである

std::ptr::copy_nonoverlapping(src, dst, count):
copyと同様だが2つのメモリ領域が重なっていない時にしか使えず高速

次に示す関数はstd::ptrモジュールに含まれている

read_unaligneed、write_unaligned:
参照先の型が要請するアライメントをポインタが満たさなくても動作するreadとwrite
→通常のreadやwriteより低速である可能性がある

read_volatile、write_volatile:
CとC++のvolatile読み出し、書き込みと同じように機能する

21.7.7 例:GapBuffer
















































































