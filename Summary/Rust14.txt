14章 クロージャ

クロージャ(closure):
無名関数式
→クロージャの使われ方によってRustが自動的に引数の型と返り値の型を推論してくれる

クロージャを受け取ることができる標準ライブラリの機能
・データ列を処理するために
・新しいシステムスレッドを開始するために(並列実行の本質:仕事を他のスレッドに渡すこと)
・デフォルト値をクロージャで渡す場合

14.1 変数のキャプチャ

クロージャは外側の関数に属するデータを使うことができる

RustはGCがないのでリターンすると変数や引数がスコープから外れて捨てられてしまう

14.1.1 借用するクロージャ

Rustはガベージコレクションではなく生存期間を使って安全性を保証する(参照を借用)

14.1.2 盗むクロージャ

スレッドは呼び出し元と並列に実行される
クロージャがリターンすると新しいスレッドは終了する(→19章)

moveキーワード
→クロージャの前につける
→そのクロージャが変数を借用するのではなく所有権を「盗む」ことをRust処理系に伝える

クロージャは外側のスコープからデータを取得する方法を2つ用意している
→移動と借用に関するルールに従う(4,5章)

・コピー可能な型は移動でなくコピーが行われる
・非コピー型は移動が起きる
・もし移動後も変数を使いたければクローンして他の変数に格納しておけば良い

スレッド安全性につながる

14.2 関数型とクロージャ型

関数とクロージャにも型がある

fn hoge(city: &City) -> i64 { ... }の型
→fn(&City)->i64

値にできることは全て関数にもできる

・変数に代入
・構造体に関数型フィールドを持たせる
・Vecに大量の関数を格納(同じfn型のみ)
・関数を引数にとる

fnの値
→関数の機械語コードのアドレス

クロージャと関数は同じ型ではない

fn(&City) -> bool    // fn type (functions only)
Fn(&City) -> bool    // Fn trait (both functions and clousures)

-> と返り値の型は省略可能(その場合は()になる)

全てのクロージャは固有の型を持つ
→外側のスコープから拝借したり移動したりしたデータが含まれるかもしれないから
→→個々のクロージャはコンパイラがアドホックに作った固有の型をもつ
→→→2つのクロージャが同じ型になることはない

全てのクロージャはFnトレイトを実装している

クロージャを使うコードはジェネリックにする必要がある

14.3 クロージャの性能

クロージャは高速に動作するように設計されている
→C++のlambdaと同じくらい速くコンパクトでより安全

ほとんどの言語はクロージャをヒープ上で扱いGCで回収するので余分なCPU時間がかかる
さらにインライン化の対象にならない場合が多い

Rustもヒープ上に確保される
呼び出そうとするクロージャの型を知ることができればインライン化することができる

Rustがクロージャの型を知っている
→メモリ上では変数への参照など(を保持する構造体)のみでよい
→→Rustがどのコードを実行すれば良いのか知っているので

クロージャはそれほど大きなメモリ空間を必要としない
→インライン化すると保持するためのわずかなメモリさえいらない

14.5 コールバックで動的に呼び出す方法を示す

14.4 クロージャと安全性

























































































