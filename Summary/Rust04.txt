4章 所有権

安全なシステムのための２つの約束
・値の生存期間はプログラマが決める。
  Rustは値に属するメモリや資源をタイミングを合わせて即座に解放する。
・解放済みのポインタを使用することはない。コンパイル時に阻止する。

→１個目はC/C++でも満たされている
→２個目を満たす言語はタイミングをガベージコレクタに一任

Rustに妥協はない
→ポインタの使い方に制約を加えることで解決
→→コンパイル時チェックを可能にした

同じルールが安全な並列機構の基盤に
→データ競合がないことを保証

Rust
→制約があってなお、十分以上の柔軟性を持つ
→メモリ管理バグや並列性バグを排除できる

本章:
ルールができた理由→ルールの詳細→例外事項

4.1 所有権
C++ 
→他者からの被所有バッファを参照するポインタは被所有者が破棄される前にプログラマが破棄

Rust
→値は唯一の所有者を持ち所有者が解放(drop)された時に同時にdropされる
→"単一所有者のルール"

変数
→let文で宣言
→その値を所有する
→→宣言されたブロックを制御が離れた時にdropされる

Box型:
Box<T>はヒープ上の型Tへのポインタ
→Box::new(v)でヒープ上にメモリを確保し値vをそこに移動しBoxを返す

所有者と所有される値
→ツリー構造をなす
→→究極のルートは変数 

deleteやfreeのように明示的に値をドロップすることはない
→なんらかの形で所有権のスコープから取り除くことで行われる

いくつかの方法でこの硬直的な構図を拡張している
・所有者を移動することができる
・stdライブラリの参照カウントポインタ型のRcとArcで制限下複数の所有者
・値への「参照の借用」ができる←所有権のないポインタ(生存期間に制限)

4.2 移動

ほとんど全ての型の代入、受け渡しの際に移動(move)される
→受け渡し元は所有権を受け渡し先に引き渡し未初期化状態になる

コピーが欲しい時は明示的に要求する
→.clone()など

参照カウントについては4.4 RcとArc:所有権の共有で

4.2.1 移動を伴う他の操作

関数の引数・返り値でも所有権の受け渡しが行われる

所有権の移動が起こってもヒープ上のバッファは不動なので非効率ではない
コンパイラの最適化も行われる

4.2.2 移動と制御フロー

一般的な原則
→ある変数から移動後新しい値が与えられていないなら未初期化状態

→ループ内で変数の値を移動するのは禁止
→→２週目になる前に新しい値を与える

4.2.3 移動とインデックスされる値

インデックスされた値の移動はできない
→３種類の方法で解決する

・.pop().wrap()で最後の値をポップ
・.swap_remove(1)で真ん中の値を抜き出し最後の要素を代わりにそこに入れる
・std::mem::replace(&mut v[n],A)で別の値を代わりに入れる

Vecのようなコレクション型
→全ての要素をループできるメソッドが用意されている

for ... in vのようにループにベクタを渡す
→ベクタはvから移動される

Option型を使えばコンパイラに管理されない形で値を移動できる
→takeメソッドが用意されている

4.3 コピー型:移動の例外

Copy型:
代入しても値は移動されずコピーされる

→数値型、char、bool、Copy型のタプル、固定長配列など

Stringなどヒープ上に値を持つものなどCopy型ではない
→他にもFile型やMutexGuardなど問題があるものは移動される
→→基準はdropされるときに特別な操作を必要とするか

独自定義型
→struct、enumはデフォルトでは非コピー型
→→属性#[derive(Copy, Clone)]をつければ良い

C++のように代入演算子のオーバーロードして特殊な実装などはできない

CopyとCloneはトレイトの例
→Rustの拡張可能なカテゴリ(詳細は11章、13章で)

4.4 RcとArc:所有権の共有

求める生存期間を持つ所有者を選ぶのが難しい時
→参照カウンタのポインタ型RcとArcを使う

Arc(atomic reference count):
複数のスレッド間で共有しても安全

Rc(reference count):
高速だがスレッド安全でないコードで参照ポインタを管理

スレッド間で共有しないのならばRcを使えば良い

Rc<T>:
ヒープ上に確保されたTとそれに付随する参照カウントを指すポインタ
→clone()してもコピーされず同じものをさすポインタが作られ参照カウンタ++

Rcのポインタ自体には通常の所有権ルールが適用される

Tの普通のメソッドはRc<T>に対して直接実行することができる

Rcポインタに所有される値は不変

参照カウントループ:
２つの参照カウントされた値がお互いに参照している場合解放されない
→内部可変(interior mutability)を扱うときに注意(9章)
→weak pointerであるstd::rc::Weakでリンクを作ればサイクルを避けられる
→→標準ライブラリのドキュメントを参照

移動・参照カウンタ→所有権ツリーを柔軟にする
３つ目の方法(参照の借用)は次章
