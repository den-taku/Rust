16章 コレクション

標準ライブラリには様々なコレクション(collection)が含まれる
→データをメモリ上に格納するジェネリック型

他の言語との体系的な差異
・移動と借用が全ての場所で起こる
・無効化によるエラーが生じない(nullがない)

16.1 概要

8つの標準コレクションが表16-1に示されている

Vec<T>:
伸長可能なヒープ上のTの配列

VecDeque<T>:
FIFOキューに向く
末尾だけでなく先頭にも値を追加したり削除したりできる(その分少し遅い)

LinkedList<T>:
先頭と末尾に高速にアクセスできる
高速に連結することができる
ただしVec<T>やVecDeque<T>よりは遅い

BinaryHeap<T>:
順序つきのキュー
効率よく最大値を取り出せるようになっている

HashMap<K, V>:
キーと値のペアからなるテーブル
キーで高速に検索する
エントリの順番は保証されない

BTreeMap<K, V>:
エントリをキーの順番でソートした状態に保つ
ソートする必要がないならHashMapの方が高速

HashSet<T>:
型Tの集合
高速に値の追加、削除ができる
ある値が集合に含まれているかを高速に判定可能

BTreeSet<T>:
要素を値の順に保つ集合
ソートする必要がないならHashSetの方が高速

16.2 Vec<T>

ベクタを作る最も簡単な方法
→vec!マクロを使う

ベクタの3つのfield
・長さ
・容量
・要素を格納するheap上に確保したbufferへのpointer

空のベクタは初期状態では容量0でヒープメモリを確保しない

Vecはstd::iter::FromIteratorを実装している
→任意のイテレータから.collect()メソッドでベクタを作れる

16.2.1 要素へのアクセス

配列やスライスやベクタから要素を取得
→インデックスを使うと簡単

ベクタの長さとインデックスの型はusizeでなければならない
→必要ならキャスト(n as usize)を用いる

ベクタやスライスの特定要素にアクセスするためのメソッド
→スライスのメソッドは全て配列やベクタでも使える

slice.first():
最初の要素があればその要素への参照を返す

slice.last():
最後の要素があればその要素への参照を返す

slice.get(index):
slice[index]が存在すればその値への参照を返す

slice.first_mut(), slice,last_mut(), slice.get(index):
それぞれ可変参照を返す

要素にアクセスするメソッドは一般に要素への参照を返す(移動させないため)

slice.to_vec():
スライス全体を複製し新しいベクタを返す
→where T: Cloneの場合にだけ使用可能

16.2.2 イテレータ処理

ベクタやスライス
→値も参照もイテレート可能

Vec<T>のイテレータ
→型Tのアイテムが1つずつ移動され消費される

&[T; N], &[T], &Vec<T>
→型&Tのアイテムを生成

&mut [T; N], &mut [T], &mut Vec<T>
→&mut Tのアイテムを生成

16.2.3 ベクタの伸長と縮小

長さ(length):
配列、ベクタ、スライスの持つ要素数

slice.len():
スライスの長さをusizeで返す

slice.is_empty():
要素が1つもなければtrueを返す

容量(capacity):
ヒープ領域に保持できる要素の最大数

Vec::with_capacity(n):
容量nの空のベクタを生成する

vec.capacity():
vecの容量をusizeで返す(capacity>=lenは恒等)

vec.reserve(v):
少なくともn個の要素を追加できる容量を確保する

vec.reserve_exact(n):
n個以上の余分な容量は持たない(c = l + nになる)

vec.shrink_to_fit():
余分なメモリを解放する

Vec<T>に要素を追加したり削除したりするメソッドはselfのmut参照をとる

vec.push(value):
指定したvalueをvecの末尾に追加

vec.pop():
末尾を削除して返す(Option型)

vec.insert(index, value):
指定したvalueをvec[index]に挿入する

vec.remove(index):
vec[index]を削除して返す

removeもinsertもずらす要素が多ければ多いほど遅くなる

vec.resize(new_len, value):
vecの長さをnew_lenにし、伸びる場合はvalueで埋める

vec.truncate(new_len):
vecを切り落としてnew_lenにする
もしlen<=new_lenなら何もしない

new.clear():
vecの全ての要素を削除する

vec.extend(iterable):
iterableから取得できるアイテムを全て末尾に順に格納

vec.split_off(index):
vencのindexよりも後ろの要素を削除し、格納したVec<T>を返す
popの多数の値を扱うversionのようなもの

vec.append(&mut vec2):
vec2の要素を全てvecに移動する
vec2は空になるだけで存在は消えない

vec.drain(range):
vecからvec[range]の範囲を削除して削除した要素に対するイテレータを返す
rangeは..や0..4などになる

vec.retain(test):
testにパスしなかった全ての要素を削除
test: FnMut(&T) -> bool

vec.dedup()
同じ値が連続していると1つを残しドロップする
→完全に重複を排除したければソートしたり別のデータ構造に入れたりretainを使う

vec.dedup_by(same):
同じかどうかの判断にsame(&mut elem1, &mut elem2)を用いる

vec.dedup_by_key(key):
key(&mut elem1) == key(&mut elem2)ならばelem1とelem2が等しいとする

resizeは値のクローンをするが他のメソッドは全て値の移動を行う

16.2.4 連結

配列の配列に対して機能するメソッドが2つある
→要素として配列、スライス、ベクタを持つ配列、スライス、ベクタの総称

slice.concat():
全てのスライスをつなげた新たなベクタを返す

slice.join(&separator):
concatとほぼ同じだが、スライスとスライスの間にseparator値のコピーを挟む

16.2.5 分割

要素への可変参照を取得するのは難しい
→同一のものから可変参照をインデックスを用いて2度以上可変参照は取れない

可変参照を借用するメソッド
→データを重複のない領域に分割するように設計されている
→→いずれも直接データ列を変更することはなく、内部データの一部へ新たな参照を返すだけ

図16-2にメソッドが示されている

slice.iter(), slece.iter_mut()
→16.2.2を参照

slice.split_at(index), slice.split_at_mut(index):
スライスを2つに分けてそれらのペアを返す((&slice[..index], &slice[index..])と等価)

slice.split_first(), slice.split_first_mut():
最初の要素への参照と、残り全部(slice[1..])への参照のペアを返す
→返り値の型はOption<(&T, &[T])>

slice.split_last(), slice.split_last_mut():
最後の要素への参照と、残り全部への参照のペアを返す

slice.split(is_sep), slice.split_mut(is_sep):
関数およびクロージャのis_sepで1つ以上のサブスライスに分割する場所を決定する
サブスライスを生成するイテレータを返す
→is_sep(&element)がtrueを返すセパレータはどのサブスライスにも含まれない
→→最低でも1つのサブスライスが返され、1つのセパレータごとに1つのサブスライスが追加される

slice.splitn(n, is_sep), slice.splitn_mut(n, is_sep):
最大でもn個のサブスライスしか作らない(n-1個のサブスライスが作られた時点で残りを1つにまとめる)

slice.rsplitn(n, is_sep), slice.rsplit_mut(n, is_sep):
スライスを逆順にスキャンする

slice.chunks(n), slice.chunks_mut(n):
長さnの重複しないサブスライスのイテレータを返す

slice.windows(n):
&slice[0..n], &slice[1..n+1], &slice[2..n+2],...を返す

16.2.6 入れ替え

slice.swap(i, j):
slice[i]とslice[j]を入れ替える

vec.swap_remove(i):
vec[i]を削除し返す。最後の要素を移動してきてギャップを埋める

16.2.7 ソートと検索

スライスには3つのソートメソッドがある

slice.sort():
要素を昇順にソートする

slice.sort_by(cmp):
ソートに用いる順序をcmpで指定(他の型のcmpを使える)
cmp: Fn(&T, &T) -> std::cmp::Ordering
→タプルを使えば引き分け時にfieldごとに見ていくことが可能

slice.sort_by_key(key):
keyを用いて得られたソートキーの昇順でソートする
key: Fn(&T) -> K where F:Ord
→ソートキーの値はキャッシュされないことに注意
→keyは要素から借用した参照を返すことができない(生存期間が推論できない)

3つとも安定ソートを行う

逆順にソートしたければsort_byを|b, a|で呼び出せば良い
→.reverse()を呼び出しても良い

slice.binary_search(&value), slice.binary_search_by(&value, cmp), slice.binary_search_by_key(&value, key):
ソートされているsliceからvalueを検索する
→返り値はResult<usize, usize>
→→Ok(index)かErr(insertion_point)を返す

浮動小数点数にはソートや二分探索のキーには使えない

slice.contains(&value):
sliceの要素のいずれかがvalueと等しければtrueを返す

スライス内での値の位置を探すにはイテレータを使う
→slice.iter().position(|x| *x == value) (Option<usize>を返す)

16.2.8 スライスの比較

ある型Tが==演算子と!=演算子をサポート
→配列[T; N]、スライス{T}、ベクタVec<T>もこれらをサポート

slice.starts_with(other):
スライスの冒頭部の列がスライスotherの要素列と等しければtrueを返す

slice.ends_with(other):
スライスの末尾列がスライスotherの要素列と等しければtrueを返す

16.2.9 ランダムな要素

乱数は標準ライブラリに含まれていない

randクレートは2つのメソッドを提供している

rng.choose(slice):
スライスからランダムに要素を選び参(Option<&T>)照を返す

rng.shuffle(slice):
スライスの要素をランダムに並び替える
→スライスはmut参照で渡す

これらはrand::Rngトレイトのメソッドなので乱数生成器Rngが必要
→rand::thread_rng()を呼べば簡単に作れる

16.2.10 Rustでは無効化エラーは生じない

多くのプログラミング言語
→コレクションに対するイテレート計算中にコレクション自身を書き換えてはいけないという制約
→→データが変更されるとイテレータが無効化されてしまう(無効化エラー)

Rustでは共有参照、可変参照の生存期間の制約によってエラーを指摘する

16.3 VecDeque<T>


















































































