17章 文字列とテキスト

この章で説明されること
・Unicode
・char型
・String型とstd型
・文字列フォーマット
・正規表現サポート
・Uniocodeの正規化

17.1 Unicodeについて

Rustの文字列はUnicodeを対象に設計されている

17.1.1 ASCII、Latin-1、Unicode

UnicodeとASCII
→ASCIIのコードポイントにおいて一致(0x00~0x7f)

同様に0x00~0xffはISO/IEC 8859-1文字セット(ASCIIの8bitスーパーセット)に割当
→西欧言語文字に用いられる
→→Latin-1 コードブロックと呼ぶ

UnicodeはLatin-1のスーパーセット

u8とcharの変換は(Latin-1の範囲内で)簡単

17.1.2 UTF-8

Stringやstr型
→テキストをUTF-8形式で表現する

UTF-8
→一文字を1Byteから4バイトの列にエンコードする

UTF-8が整形式(well-formed)であるための制約
・全てのコードポイントに対して最短のエンコーディングだけが整形式
・0xd800~0xdfffと0x10ffff以上の値はエンコードしてはいけない

UTF-8は0x00~0x7fのコードポイントをそのまま0x00~0x7fのバイトに変換
→ASCIIのバイト列⇔有効なUTF-8(0x00~0x7f)

任意のバイトの上位コードでUTF-8の最初のByteかどうかを判断できる
→さらに最初のByteを見れば何Byteで表現されているかわかる

4Byteより長くはエンコードされない
→無限ループが必要にならない

バイト列の途中から見てもどこで始まりどこで終わるかがわかる
→ある整形式がある整形式の一部になっていることはないということ

可変幅エンコードは固定幅エンコードよりも複雑
→しかし各性質を生かせばそこまで難しいわけでもない

17.1.3 テキストの向き

Unicodeでは通常読み書きされる順に文字を格納する
→next()やleft,rightに注意

17.2 文字(char)

char型:
Unicodeのコードポイントを保持する32bitの値
→0~0xd7ffまたは0xe000から0x10ffffまでの値にあることが保証されている

有用なトレイトを全て実装している

17.2.1 文字の分類

文字を一般的なカテゴリに分類するメソッドがある(真偽値を返す)

ch.is_numeric():
数字

ch.is_alphabetic():
アルファベット文字

ch.is_alphanumerric():
数字もしくはアルファベット

ch.is_whitespace():
ホワイトスペース

ch.is_control():
制御文字

17.2.2 数字の取り扱い

ch.to_digit(radix):
chが基数radixのもとで数字であるかを判断しOption<u32>で返す

std::char::from_digit(num, radix):
u32の数値numを可能ならばcharに変換する(10よりも大きい場合はchは小文字)

ch.is_digit(radix):
もしchが基数radixの元でASCII数字ならばtrueを返す

17.2.3 文字の大文字小文字変換

ch.is_lowercase()、ch.is_uppercase():
chが小文字か大文字かを返す

ch.to_lowercase()、ch.to_uppercase():
chに対応する小文字列もしくは大文字列を生成するイテレータを返す(Optionのイテレータ)
→大文字小文字の変換は1文字とは限らないのでイテレータで返す
→→便宜上このイテレータはstd::fmt::Displayを実装しているので直接println!マクロなどに渡せる

17.2.4 整数との間の変換

as演算子
→charを任意の整数型に変換可能
→→上位bitは警告なしで丸められる

任意のu8値をcharにすることも可能
→charはFrom<u8>も実装している

よりbit数の大きな整数型はOptionを返すstd::char::from_u32を使う

17.3 Stringとstr

String型とstr型
→整形式なUTF-8を保持することを保証する
→→値を作る方法と操作を制限してこれを保証する

サイズ可変なバッファが必要ならString、既にあるテキストをそのまま使えるならstrにメソッド定義
→Stringは&strに参照解決できるのでstr定義メソッドはそのまま使える

各メソッドはByte単位でインデックス参照する
→その方が速く単純

String
→常に内容が整形式なUTF-8となるようラップされたVec<u8>として実装

表記の変数名はp387の表を参照すべし

17.3.1 String値の作成

String値を作るメソッドはいくつかある

String::new():
新たな空の文字列を返す

String::with_capacity(n):
ヒープ上に少なくともnバイトを保持できるバッファを確保してnewする

文字列にもcapacity、reserve、shrink_to_fitメソッドがあるがほぼ不要

slice.to_string():
sliceをコピーして新しい文字列をヒープ上に作る

iter.collect():
イテレータのアイテムをつなぎ合わせて文字列を構築する
→アイテムはchar、&str、Stringのいずれでも良い

&strはCloneトレイトを実装できないためToOwnedトレイトを実装する
→slice.to_owned()はsliceをコピーした新しいStringを返す

17.3.2 単純な検査

文字列スライスから基本的な情報を取得する

slice.len():
sliceの長さをバイト単位で返す

slice.is_empty():
slice.len()==0なら真

slice[range]:
sliceの指定された範囲を借用したスライスを返す

slice[i]のようにインデックスで扱うことはできない
→charsイテレータを作れば文字ごとにパースして扱えば良い
→→ただし17.3.8でより良いイテレート方法を紹介

slice.split_at(i):
スライスをバイトオフセットiで分割した2つのスライスへの借用のタプルを返す

slice.is_char_boundary(i):
バイトオフセットiが文字境界ならtrueを返す

17.3.3 テキストの追加と挿入

以下のメソッドはStringにテキストを追加する

string.push(ch):
stringの末尾にchを追加

string.push_str(slice):
sliceを全て末尾に追加

slring.extend(iter):
イテレータのアイテムをstringに追加
→std::iter::Extendの実装によるもの

string.insert(i, ch):
chをバイトオフセットiの場所に挿入する
→文字列の長さの二乗の時間がかかる

string.insert_str(i, slice):
sliceをinsertする

Stringはstd::fmt::Writeを実装している
→write!マクロやwriteln!マクロでStringにフォーマットしたテキストを追加できる

write!、writeln!は出力ストリームに書き出す
→Resultを返す

StringはAdd<&str>とAddAssign<&str>を実装しているので+や+=を使える
→対称性はないので&strを左オペランドには取れない

17.3.4 テキストの削除

string.clear():
stringを空にする

string.trucate(n):
バイトオフセットn以降の持っ寺を全て捨てる

string.pop():
最後の文字があれば削除して返す

string.remove(i):
バイトオフセットiの文字をstringから削除して返す

string.drain(range):
rangeのイテレータを返し、イテレータがdropされるとその範囲の文字を削除する
→削除したいだけならアイテムを取り出さずにdropすれば良い

17.3.5 検索とイテレート関数の名前付け

テキスト検索やイテレートを行う標準ライブラリ関数の命名規則

・ほとんどの処理は先頭から末尾。rから始まるものは逆
・末尾にnがつくと指定したマッチ数で生成するアイテム数を制限
・末尾に_indicesがつくイテレータはアイテム+そのアイテムがスライス上に現れるバイトオフセットも生成

17.3.6 パターンによるテキスト検索

検索、マッチ、分割、トリムなどを行う標準ライブラリ関数がある
→引数としていくつかの型を受け付け、その型に応じて探すものを変える
→→パターン(pattern)と呼ばれる

標準ライブラリがサポートする主要なパターン型は4つ
・charは文字にマッチ
・String、&str、&&strは部分文字列にマッチ
・FnMut(char) -> boolはクロージャが真を返す一文字にマッチ
・&[char](char値の文字列)はスライス中の全ての文字にマッチ
→固定長配列にはマッチしないのでリテラルの配列としてリストを書いたならas演算子で型を合わせる必要がある

パターン
→std::str::Patternトレイトを実装した任意の型

17.3.7 検索と置換

スライス中のパターンを検索するメソッド、新しいテキストに置換するメソッドを用意している

slice.contains(pattern):
patternにマッチする部分があれば真を返す

slice.starts_with(pattern)、slice.ends_with(pattern):
冒頭もしくは末尾がpatternにマッチすれば真を返す

slice.find(pattern)、slice.rfind(pattern):
マッチする部分があればバイトオフセットiをSome(i)として返す

slice.replace(pattern, replacement):
patternにマッチした部分全てreplacementに置き換えた新たなStringを返す

slice.replacen(pattern, replacement, n):
最大で最初のn個だけしか置換しない

17.3.8 テキストに対するイテレート

split系メソッドとmatch系メソッドは相補関係にある

slice.chars():
各文字を生成するイテレータを返する

slice.chars_indices():
各文字とバイトオフセットを生成するイテレータを返す
→.chars().enumerate()とは異なりスライス上でのバイトオフセットを返す

slice.bytes():
各バイトを生成するイテレータを返す
UTF-8エンコードされた値をそのまま生成

slice.lines():
各行を生成するイテレータを返す

slice.split(pattern):
patternにマッチする部分で区切られた範囲を生成するイテレータを返す

slice.rsplit(pattern):
sliceの末尾からsplitする

slice.split_terminator(pattern)、slice.rsplit_terminator(pattern):
patternがセパレータではなくターミネータとしてsplitされる
→末尾とマッチした時に空文字列を生成しない

slice.splitn(n, pattern):
最大でもnスライスにしか分割しない

slice.split_whitespace():
ホワイトスペース(連続したものは1つ分扱い)で分割したイテレータを返す

slice.matches(pattern):
patternにマッチした部分を生成するイテレータを返す

slice.rmatches(pattern):
末尾から処理する

slice.match_indices(pattern):
(offset, match)のペアを生成するイテレータを返す

17.3.9 トリミング

文字列のトリミング:
文字列の冒頭もしくは末尾からなんらかのテキストを削除すること
→ファイルからの入力を整えるのに便利

slice.trim():
冒頭と末尾にあるホワイトスペースを削除したsliceのサブスライスを返す
→slice.trim_left()は冒頭のみ、slice.trim_right()は末尾のみ取り除く

slice.trim_matches(pattern):
冒頭と末尾からpatternにマッチするものを全て削除したサブスライスを返す

17.3.10 文字列の大文字小文字変換
































































































































