3章 基本的な型

Rustの型の目的:
安全性→コンパイラでチェック
効率性→不要な汎用性や柔軟性を排除
簡潔性→C++よりも簡潔なプログラム

Rust:静的に型付けされた(statically typed)言語
→コンパイラが事前に型チェック
→→事前に明示的に型を選ぶ
→→→補助する２つの機能

推論(infer):
一意に定まる変数や式の型をコンパイラ自身が決定

ジェネリック(generic):
必要な条件を満たす全ての型に対して機能するような関数定義(duck typing)
関数の目的と実装が十分一般的である必要がある
→詳しくは11章 トレイトとジェネリクスで

3.1 機械語型

型の基盤:固定長の数値型と真偽値と文字列
→ハードウェア上の実装と合致

数値型
→サイズ(bit)と表現方法で名前を表現
計算機のワード長(machine word)
→プログラムが実行される計算機でのアドレスサイズ。普通32か64。

bit   符号なし整数 符号付き整数 浮動小数点数
 8    u8           i8
16    u16          i16
32    u32          i32          f32 
64    u64          i64          f64
word  usize        isize

3.1.1 整数型

符号なし整数
→0と正の値を表現
符号つき整数
→2の補数表現で正の数と負の数を表現

→char型とは区別される
→ただしバイトリテラル(byte literals)ではASCIIコードを格納可能
→→ b'A' == 65u8
→→→ただしエスケープ必要な文字もあり \' \\ \n \r \t
→→→16進数で書くこともできる b'\xHH'

usize isize:
実行対象計算機のアドレス空間サイズ。
配列のインデックスやサイズ、データ構造の要素数なども一般にusize

デバッグビルド時
→数値演算のオーバーフローをチェック
リリースビルド時
→オーバーフローはラップ(wrap)
→→デバッグビルド時等常にラップしたいのなら次のように書く
 let x = big_val.wrapping_add(1);

整数リテラル
→型を後ろにつける 42u8 1729isize
→→推論で一意に決まればその型
→→i32が残ればi32
→→推論でi32が残らなければエラー

0x:16進数のリテラル
0o: 8進数のリテラル
0b: 2進数のリテラル
→アンダースコア(_)を入れてもよい 4_294_967_295 0xffff_ffff 127_u8

整数型から整数型への変換
→as演算子(詳しくは6.13 型キャスト)
→→変換先の範囲からはみ出す場合は2^Nによる剰余(N:変換先のbit数)
→→→切り捨て(truncation)という

整数もメソッドを持てる
→オンラインドキュメントでstdライブラリの操作を確認可(std::i32等で検索)
→→pow abs count_ones など

→呼び出し順:メソッド呼び出し>単項前置演算子
→→-4i32.abs() = -4

3.1.2 浮動小数点数

f32:IEEE単精度
f63:IEEE倍精度

(整数部)(.小数部)(指数部)(型指定子)
        31415.926e-4f64
小数部以降は省略可能だが、整数リテラルと区別するためどれか１つは必要
→小数点のみで小数部は表記可能
→→f32とf64どちらにも推論可能な時、f64が選ばれる

std::f32,std::f64には以下のものが定義
INFINITY, NEG_INFINITY, NAN, MIN, MAX

std::f32::consts,std::f64::constには様々な数学の定数が定義
→E,PI,√2...

f32やf64には一連の数学計算用のメソッドが定義されている

"暗黙の"型変換はコンパイルされない
→型変換はas演算子で(詳しくは6.13 型キャスト)

型推論は関数定義の中で閉じているので引数や戻り値から推論はされない

3.1.3 真偽値型

bool:
true or false (1Byte)

真偽値が必要な場合
→厳密にbool式でなくてはいけない

assert_eq!(false as i32, 0);
assert_eq!(true  as i32, 1);

as演算子:
bool -> numeric literal : Ok
numeric literal -> bool : Dame

3.1.4 文字

Unicode1文字
→char型(32bit)で表現

文字列やテキストのストリーム
→String(UTF-8バイト列):文字の配列で保持するのではない

char型文字リテラル
シングルクォート(')で囲む。任意のUnicode文字を使用可能。
いくつかの文字は\によるエスケープが必要
→0x0000~0xD7FF、または0xE000~0x10FFFFのUnicodeコードポイントを保持

Unicodeコードポイントを16進数で書くこともできる
→U+0000~U+007Fなら'\xHH' 例えば'*' = '\x2A' 
→任意のUnicodeなら'\u{HHHHHH}' 

暗黙のキャストはできず、asで整数型に変換可
→ただしオーバーフロー分は丸められる
逆方向の変換はu8->charのみ
→→u8のみが安価で失敗する可能性がない
→→→std::char::from_u*は任意のu*を受けとりNone or Some(c)

標準ライブラリは文字クラスに対する有用なメソッドを提供

String型とテキスト処理→3.5 文字列へ

3.2 タプル

タプル(tuple):
様々な型の組み合わせの組を表現する型
タプルtの要素はt.0、t.1のようにしてアクセス
関数の返り値として有用

("Brazil", 1985) : (&str, i32)
→最後の要素の,はあってもなくても良い
→→Rustでは全ての場合で最後の,を許す

1要素のタプル
→値の後ろのタプルは必須

配列との違い
・個々の要素が異なる型を持てる
・t.4のように定数のインデックスしか使えない(t.iで走査とかはできない)

タプルは「退屈な」構造体のようなもの(構造体は９章)

ユニット型(unit type):
0要素のタプル()のこと

3.3 ポインタ型

Rustにはメモリアドレスを表す型がいくつかある
ある値から別の値を指す場合には必ず明示的にポインタを用いる

3.3.1 参照

&:参照(refと発音)
→基本的なポインタ型。どこにある値でも指すことができる
→→&x : 「xへの参照を借用する」という

参照rに対して*r
→rが指す値を取得する

参照がスコープから消えても自動的になんらかの資源を解放しない

決してnullにならない
可変参照→&mut T
値の所有権と生存期間はコンパイラが管理→詳しくは５章

3.3.2 Box

ヒープ上に値を確保する最も簡単な方法→Box::new

Box<T>:
Tを格納するのに十分なメモリをヒープに確保する
事前に移動(move)されていない限り、スコープから外れると即座に解放される
→詳しくは4章

3.3.3 rawポインタ

*mut Tと*const T:
rawポインタ型

→Rustが全く管理してくれないので安全ではない
→→C++で起こるような古典的なポインタ関連のエラーが楽しめる↑
→→→ただしunsafeブロック内でしか扱えない

詳しくは21章で

3.4 配列、ベクタ、スライス

メモリ上に値の列を表現する方法→３種類

配列 [T; N]
→サイズがコンパイル時に定まる。伸縮不可

ベクタ Vec<T>
→要素はヒープ上に取られる。可変長。

共有スライス　可変スライス &[T] &mut [T]
→一部の連続した要素への参照。最初の要素へのポインタと要素数を持っている

3.4.1 配列

以下のように初期化する
let tmp: [u32; 6] = [1, 2, 3, 4, 5, 6,];
let tmp = [true, 1000];
→初期化されていない配列を作る記法はない

配列の長さは型の一部でコンパイル時に決定される
→変数で長さを指定したりはできない

配列に有用なメソッドはスライスのメソッドとして定義
→配列への参照は暗黙にスライスに変換される

スライスの詳細→3.4.4 スライス

3.4.2 ベクタ

ヒープ上に確保される

作成方法はいろいろある
→vec!マクロ、Vec::new()、collect()

配列と同様、スライスメソッドを利用可能
Vecを拡張するメソッド→16章で詳しく

Vec<T>は３つの値で構成される
・ヒープ上にアロケートされたバッファへのポインタ
・バッファに保持できる最大容量
・現在保持している要素数
→最大容量を超えた場合、大きなバッファが再確保されコピー・移動される
→→要素数が前もって分かっているならVec::with_capacityで事前に確保できる

3.4.3 ベクタを1要素ずつ作る

Vec::newではなくVec::with_capacityを使っても定数倍の速度改善にすぎない

3.4.4 スライス

[T]のように書く
任意の長さであり得るので、直接変数に格納したり引数として渡せない
常に参照として渡される

スライスの参照:ファットポインタ

通常の参照→単独の値に対する所有権のないポインタ
スライスへの参照→複数の値に対する所有権のないポインタ

関数の引数をスライスへの参照に
→配列 / ベクタ、スタック上 / ヒープ上問わず動作 

                vec            array            slice1      slice2 
     _________________________________________________________________ 
Stuck|   |   | 4 | 4 |   |0.0|-0.7|-1.0|0.7|  |   | 4 |   |   | 4 |
     ------|---------------↑--------------------|-----------|---------
           |               L____________________」          | 
           L_____   ________________________________________」     
              ___↓_↓_______________
Heap            |0.0|0.7|1.0|0.7| 
              ---------------------






























































































































































































































































































