4章 所有権

安全なシステムのための２つの約束
・値の生存期間はプログラマが決める。
  Rustは値に属するメモリや資源をタイミングを合わせて即座に解放する。
・解放済みのポインタを使用することはない。コンパイル時に阻止する。

→１個目はC/C++でも満たされている
→２個目を満たす言語はタイミングをガベージコレクタに一任

Rustに妥協はない
→ポインタの使い方に制約を加えることで解決
→→コンパイル時チェックを可能にした

同じルールが安全な並列機構の基盤に
→データ競合がないことを保証

Rust
→制約があってなお、十分以上の柔軟性を持つ
→メモリ管理バグや並列性バグを排除できる

本章:
ルールができた理由→ルールの詳細→例外事項

4.1 所有権
C++ 
→他者からの被所有バッファを参照するポインタは被所有者が破棄される前にプログラマが破棄

Rust
→値は唯一の所有者を持ち所有者が解放(drop)された時に同時にdropされる
→"単一所有者のルール"

変数
→let文で宣言
→その値を所有する
→→宣言されたブロックを制御が離れた時にdropされる

Box型:
Box<T>はヒープ上の型Tへのポインタ
→Box::new(v)でヒープ上にメモリを確保し値vをそこに移動しBoxを返す

所有者と所有される値
→ツリー構造をなす
→→究極のルートは変数 

deleteやfreeのように明示的に値をドロップすることはない
→なんらかの形で所有権のスコープから取り除くことで行われる

いくつかの方法でこの硬直的な構図を拡張している
・所有者を移動することができる
・stdライブラリの参照カウントポインタ型のRcとArcで制限下複数の所有者
・値への「参照の借用」ができる←所有権のないポインタ(生存期間に制限)

4.2 移動

ほとんど全ての型の代入、受け渡しの際に移動(move)される
→受け渡し元は所有権を受け渡し先に引き渡し未初期化状態になる

コピーが欲しい時は明示的に要求する
→.clone()など

参照カウントについては4.4 RcとArc:所有権の共有で



































































































