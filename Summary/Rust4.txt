4章 所有権

安全なシステムのための２つの約束
・値の生存期間はプログラマが決める。
  Rustは値に属するメモリや資源をタイミングを合わせて即座に解放する。
・解放済みのポインタを使用することはない。コンパイル時に阻止する。

→１個目はC/C++でも満たされている
→２個目を満たす言語はタイミングをガベージコレクタに一任

Rustに妥協はない
→ポインタの使い方に制約を加えることで解決
→→コンパイル時チェックを可能にした

同じルールが安全な並列機構の基盤に
→データ競合がないことを保証

Rust
→制約があってなお、十分以上の柔軟性を持つ
→メモリ管理バグや並列性バグを排除できる

本章:
ルールができた理由→ルールの詳細→例外事項

4.1 所有権
C++ 
→他者からの被所有バッファを参照するポインタは被所有者が破棄される前にプログラマが破棄

Rust
→値は唯一の所有者を持ち所有者が解放(drop)された時に同時にdropされる
→"単一所有者のルール"

変数
→let文で宣言
→その値を所有する
→→宣言されたブロックを制御が離れた時にdropされる

Box型:
Box<T>はヒープ上の型Tへのポインタ
→Box::new(v)でヒープ上にメモリを確保し値vをそこに移動しBoxを返す

所有者と所有される値
→ツリー構造をなす
→→究極のルートは変数 

deleteやfreeのように明示的に値をドロップすることはない
→なんらかの形で所有権のスコープから取り除くことで行われる

いくつかの方法でこの硬直的な構図を拡張している
・所有者を移動することができる
・stdライブラリの参照カウントポインタ型のRcとArcで制限下複数の所有者
・値への「参照の借用」ができる←所有権のないポインタ(生存期間に制限)

4.2 移動

ほとんど全ての型の代入、受け渡しの際に移動(move)される
→受け渡し元は所有権を受け渡し先に引き渡し未初期化状態になる

コピーが欲しい時は明示的に要求する
→.clone()など

参照カウントについては4.4 RcとArc:所有権の共有で

4.2.1 移動を伴う他の操作

関数の引数・返り値でも所有権の受け渡しが行われる

所有権の移動が起こってもヒープ上のバッファは不動なので非効率ではない
コンパイラの最適化も行われる

4.2.2 移動と制御フロー

一般的な原則
→ある変数から移動後新しい値が与えられていないなら未初期化状態

→ループ内で変数の値を移動するのは禁止
→→２週目になる前に新しい値を与える


































































































