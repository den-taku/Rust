11章 トレイトとジェネリクス

まだ書かれていない型の値を処理できる
→多相性もしくはポリモルフィズム(polymorphism)

Rustはpolymorphismをトレイトとジェネリクスでサポート

トレイト(trait)
→Rustにおけるインターフェイス、もしくは抽象基底クラスのようなもの

Write(型名)
→意味:Writeトレイトを実装している任意の値

ジェネリクス(generics)
→様々な型の値に対してジェネリック関数やジェネリック型を使える

<T: Ord>
→Ordトレイトを実装する任意の型T(順序付け可能な型)

コンパイラは実際に使うそれぞれの型Tに対して専用の機械コードを生成

ジェネリクスとトレイトは密接に関連している
→<=演算子を使う前にT: Ordと書いてTへの要請(制約(bound))を宣言しなければならない
→→&mut Write, <T: Write>の類似点、相違点について本章で説明

11.1 トレイトの使い方

トレイト
→任意の型がサポートすることのできる性質
→→多くの場合トレイトは何らかの機能を表す

トレイトメソッド
→トレイト自体がスコープに入っていなければならない(useを使う)
→→任意のメソッドを任意の型に追加できるので名前が衝突する可能性があるから

CloneとIteratorのメソッドは何もimportしなくても使える
→常にdefaultでスコープに入っているから(13章でpreludeは紹介)

仮想関数に似ているが通常のメソッドと同程度に高速
→Vec<u8>::write()を単に呼び出せば良い(多相性はない)
→&mut Writeを使って呼び出す場合にだけ仮想メソッド呼び出しのオーバークロックが生じる

11.1.1 トレイトオブジェクト

トレイトを使って多相性のあるコードを書く方法は２つ
・トレイトオブジェクト←まずこっちから
・ジェネリクス

トレイトの型の変数は持てない
→コンパイル時にサイズが定められないので
→→Rustでは参照であることを明示しなくてはならない

トレイトオブジェクト(trait object):
トレイト型への参照
→コンパイル時に参照先の実際の型がわからない
→→Rustが舞台裏で使う参照先の型情報が追加されている

11.1.2 トレイトオブジェクトのメモリ配置

メモリ上のトレイトオブジェクト
→ファットポインタ(値へのポインタと、値の型を表すテーブルへのポインタ):2words
→→C++で言う仮想テーブル(virtual table)
→→→コンパイル時に一度だけ作られ同じ型のオブジェクト全てで共有
→→→仮想テーブル、ポインタともに直接触ることはできない

仮想テーブルへのポインタ
・C++:構造体の一部として
・Rust:ファットポインタとして(構造体にはfieldのみ)
→大量のトレイト実装時に構造体に大量のvptrを持たなくて良い

Rustは通常の参照を必要に応じて自動的にトレイトオブジェクトにする
→Box<Write>も値へのポインタとvtableへのポインタをもつファットポインタになる
→→トレイトオブジェクトはこの手の変換でしか作れない
→→→変換時には参照先の真の型を知っているので適切にvtableとつなぐ

11.1.3 ジェネリック型

<W: Write>:
型パラメータ(type parameter)。関数をジェネリックにする
→実際に呼び出した型Tに応じて呼ばれる関数が変わる。hoge::<T>()

型パラメータに複数の機能を要求
→+記号を用いる

genericは複数のtypeパラメータを持つことができる

制約は長大になることがある
→キーワードwhereを使って制約を分けて書くことができる
→→whereキーワードは構造体や列挙型などの型制約をかける全ての構文で使える

fn hoge<M, R>(...) -> Far
    where M: T1 + T2,
          R: T3 + T4 + T5
{ ... }

生存パラメータと型パラメータは両方持つことができる
→生存パラメータを先に書く

生存期間は機械語レベルのコードには影響を与えない
→異なる型の値が与えられたときのみジェネリック関数は複数の機械語にコンパイルされる

関数だけがジェネリックになるわけではない
→型、個々のメソッド、型エイリアス、ジェネリックトレイト...
→→制約、where、生存期間パラメータは全てのジェネリックなアイテムで利用可能

11.1.4 どちらを使うべきか

どちらもトレイトに基づいているので多くの点が共通している

複数の型が入り混じっているコレクション
→トレイトオブジェクトを使うのが正しい

struct Salad<V: Vagetable> → 1種類の野菜しか
Vec<Vegetable>             → Vegetable値はまちまちなので不可能
→Vec<Box<Vegetable>>(トレイトオブジェクト)を使えば良い

コンパイルされた出力コードの総量を減らす
→トレイトオブジェクトを使えば良い
→→ジェネリクスは使用した型ごとに何度もコンパイルする(コード肥大化(code bloat))

これ以外ではジェネリクスの方が2つの点において優れている
・スピード
→コンパイル時に型がわかっているので動的に分岐しない
→機械語コードを生成する段階で最適化を行うのに必要な情報を全て持っている
・全てのトレイトがトレイトオブジェクトをサポートするとは限らない
→スタティックメソッドなどはジェネリクスでしか使えない

11.2 トレイトの定義と実装

トレイト定義
→名前をつけて、トレイトメソッドのシグネチャを並べるだけ

トレイトを実装するには impl trait_name for type_nameをいう構文 
→このimplブロックにはトレイトのメソッドの実装しか書けない
→トレイトの機能でないメソッドは別のimplブロックで定義

11.2.1 デフォルトメソッド























































































