11章 トレイトとジェネリクス

まだ書かれていない型の値を処理できる
→多相性もしくはポリモルフィズム(polymorphism)

Rustはpolymorphismをトレイトとジェネリクスでサポート

トレイト(trait)
→Rustにおけるインターフェイス、もしくは抽象基底クラスのようなもの

Write(型名)
→意味:Writeトレイトを実装している任意の値(の型)

ジェネリクス(generics)
→様々な型の値に対してジェネリック関数やジェネリック型を使える

<T: Ord>
→Ordトレイトを実装する任意の型T(順序付け可能な型)

コンパイラは実際に使うそれぞれの型Tに対して専用の機械コードを生成

ジェネリクスとトレイトは密接に関連している
→<=演算子を使う前にT: Ordと書いてTへの要請(制約(bound))を宣言しなければならない
→→&mut Write, <T: Write>の類似点、相違点について本章で説明

11.1 トレイトの使い方

トレイト
→任意の型がサポートすることのできる性質
→→多くの場合トレイトは何らかの機能を表す

トレイトメソッド
→トレイト自体がスコープに入っていなければならない(useを使う)
→→任意のメソッドを任意の型に追加できるので名前が衝突する可能性があるから

CloneとIteratorのメソッドは何もimportしなくても使える
→常にdefaultでスコープに入っているから(13章でpreludeは紹介)

仮想関数に似ているが通常のメソッドと同程度に高速
→Vec<u8>::write()を単に呼び出せば良い(多相性はない)
→&mut Writeを使って呼び出す場合にだけ仮想メソッド呼び出しのオーバークロックが生じる

11.1.1 トレイトオブジェクト

トレイトを使って多相性のあるコードを書く方法は２つ
・トレイトオブジェクト←まずこっちから
・ジェネリクス

トレイトの型の変数は持てない
→コンパイル時にサイズが定められないので
→→Rustでは参照であることを明示しなくてはならない

トレイトオブジェクト(trait object):
トレイト型への参照
→コンパイル時に参照先の実際の型がわからない
→→Rustが舞台裏で使う参照先の型情報が追加されている

11.1.2 トレイトオブジェクトのメモリ配置

メモリ上のトレイトオブジェクト
→ファットポインタ(値へのポインタと、値の型を表すテーブルへのポインタ):2words
→→C++で言う仮想テーブル(virtual table)
→→→コンパイル時に一度だけ作られ同じ型のオブジェクト全てで共有
→→→仮想テーブル、ポインタともに直接触ることはできない

仮想テーブルへのポインタ
・C++:構造体の一部として
・Rust:ファットポインタとして(構造体にはfieldのみ)
→大量のトレイト実装時に構造体に大量のvptrを持たなくて良い

Rustは通常の参照を必要に応じて自動的にトレイトオブジェクトにする
→Box<Write>も値へのポインタとvtableへのポインタをもつファットポインタになる
→→トレイトオブジェクトはこの手の変換でしか作れない
→→→変換時には参照先の真の型を知っているので適切にvtableとつなぐ

11.1.3 ジェネリック型

<W: Write>:
型パラメータ(type parameter)。関数をジェネリックにする
→実際に呼び出した型Tに応じて呼ばれる関数が変わる。hoge::<T>()

型パラメータに複数の機能を要求
→+記号を用いる
→genericは複数のtypeパラメータを持つことができる

制約は長大になることがある
→キーワードwhereを使って制約を分けて書くことができる
→→whereキーワードは構造体や列挙型などの型制約をかける全ての構文で使える

fn hoge<M, R>(...) -> Far
    where M: T1 + T2,
          R: T3 + T4 + T5
{ ... }

生存パラメータと型パラメータは両方持つことができる
→生存パラメータを先に書く

生存期間は機械語レベルのコードには影響を与えない
→異なる型の値が与えられたときのみジェネリック関数は複数の機械語にコンパイルされる

関数だけがジェネリックになるわけではない
→型、個々のメソッド、型エイリアス、ジェネリックトレイト...
→→制約、where、生存期間パラメータは全てのジェネリックなアイテムで利用可能

11.1.4 どちらを使うべきか

どちらもトレイトに基づいているので多くの点が共通している

複数の型が入り混じっているコレクション
→トレイトオブジェクトを使うのが正しい

struct Salad<V: Vagetable> → 1種類の野菜しか
Vec<Vegetable>             → Vegetable値はまちまちなので不可能
→Vec<Box<Vegetable>>(トレイトオブジェクト)を使えば良い

コンパイルされた出力コードの総量を減らす
→トレイトオブジェクトを使えば良い
→→ジェネリクスは使用した型ごとに何度もコンパイルする(コード肥大化(code bloat))

これ以外ではジェネリクスの方が2つの点において優れている
・スピード
→コンパイル時に型がわかっているので動的に分岐しない
→機械語コードを生成する段階で最適化を行うのに必要な情報を全て持っている
・全てのトレイトがトレイトオブジェクトをサポートするとは限らない
→スタティックメソッドなどはジェネリクスでしか使えない

11.2 トレイトの定義と実装

トレイト定義
→名前をつけて、トレイトメソッドのシグネチャを並べるだけ

トレイトを実装するには impl trait_name for type_nameをいう構文 
→このimplブロックにはトレイトのメソッドの実装しか書けない
→トレイトの機能でないメソッドは別のimplブロックで定義

11.2.1 デフォルトメソッド

デフォルト実装
→トレイトにデフォルトで実装されているもの。再定義しないとこれが用いられる
→トレイト定義に書き込む

Iteratorトレイトなどは何十ものデフォルトメソッドを定義

11.2.2 トレイトと他人の定義した型

任意の型に対して任意のトレイトを実装することができる
→ただしトレイトか型どちらかがそのスコープで新たに導入されたときのみ(一貫性ルール)
→→任意の型に対していつでもトレイトを使ってメソッドを追加できるということを意味する
→→→そのメソッドはトレイトがスコープに入っているときだけ利用できる

拡張トレイト(extension trait):
既存の型にメソッドを追加するために存在するトレイト

ジェネリックimplブロックを書いて色々な型に対して一気に拡張トレイトを追加することできる
→impl<T: Hoge> Name for T

一貫性ルール(coherence rule)によってトレイトの実装が１つしかないことを保証
→C++では単一定義の原則(ODR: One Definition Rule)。未定義動作になる

(useによるインポート:moduleのアイテムを型エイリアスで使えるようにする)

11.2.3 トレイトでのSelf

キーワードSelfを型として使える
→例えばx.hoge()の型がxと同じということを表す

Self型を使うトレイトにはトレイトオブジェクトは使えない
→トレイトオブジェクトに対してSelf型を使うメソッドを呼んだ時に型チェックをする方法がないので

トレイトオブジェクトの存在意義:
実行時まで型がわからない点
→最も単純な類のtraitに使うことを意図している
→→トレイトの有用で高度な機能はトレイトオブジェクトとは共存できない
→→→Rustが型チェックに使う型の情報が失われるから

11.2.4 サブトレイト

あるトレイトが他のトレイトの拡張であると宣言できる

trait TraitA: TraitB {...}
→TraitAはTraitBも実装しなくてはならない
→→TraitAだけ実装してTraitBを実装していないとエラーになる

11.2.5 スタティックメソッド

ほとんどのオブジェクト指向言語
→インターフェイスにスタティックメソッドやコンストラクタを持つことができない

Rust
→static methodやconstractorを持つことができる

非ジェネリックコードでは::構文を用いて呼び出せる
ジェネリックコオオードでも同様。型の部分が型変数になる

トレイトオブジェクトはスタティックメソッドをサポートしない
→もし使いたければトレイトを変更してスタティックメソッドに制約を追加

where Self: Sized
→トレイト`オブジェクトはこれらのメソッドをサポートしなくても良いという指示
→→詳細は13章

何故これでうまくいくかというのは長く技術的で退屈な話になるのでここでは省略

11.3 完全修飾メソッド呼び出し

次の4つの呼び出しは等価
"hello".to_string()
str::to_string("hello")
ToString::to_string("hello")
<str as ToString>::to_string("hello")

value.method()以外の呼び出し:
修飾メソッド呼び出し
→メソッドが関連付けられている型かトレイトを明示的に指定している

<>を使った呼び出し型:
完全修飾(fully qualified)メソッド呼び出し
→型とトレイトの両方を指定している

.演算子と用いた呼び出し
→どのmethod()を呼び出すか指定しない
→→Rustのメソッド探索アルゴリズムが決定する

完全修飾呼び出し
→明示的に指定

同じ名前のメソッドがあるときやself引数の型が推論できない時などに役立つ
→static methodでも利用可能

11.4 型と型の関係を定義するトレイト

traitは複数の型が連携して動作するような場合にも利用できる

重要なのはトレイトやメソッドシグネチャが関係する型について何を言っているのか理解するスキル

11.4.1 関連型:イテレータはどう機能するか

イテレータ:
何らかの値の列に対する順次処理を表現したオブジェクト

Rustの標準トレイトIterator

pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
    ...
}

type Item;
→関連型(associated type)
→→Iteratorを実装する個々の型は生成する型を指定しなければならない

Self::Itemとして使う
→個々のイテレータ型が指定する型であって独立した型ではないから

ある型に対してIteratorを定義する方法

impl Iterator for Args {
    type Iter = String;

    fn next(&mut self) -> Option<String> { ... }
    ...
}

Iterator<Item=String>:
Stringを生成するIteratorの部分集合
→トレイトの名前を用いるところ全てで使用できる

関連型を持つトレイト
→全ての方が明示されているときのみトレイトメソッドでも使える

トレイトでメソッドを実行する以上のことをしたければ一般に有用
→関係する型が1つしかない場合には適している

11.4.2 ジェネリックトレイト:演算子オーバーロードはどう機能するか

trait Hoge<BAR>:
ジェネリックトレイト
→与えられた型によって別々のトレイトになる

<BAR=Self>
→BARのデフォルトがSelfであるということ
→→制約にwhere T: BAR と書くとwhere T: Mul<T>と同じ意味

11.4.3 バディトレイト:rand::random()はどう機能するか

バディトレイト(buddy trait)
→単に連携して動作するように設計されたトレイト

rand::random()
→乱数を生成

Rngトレイト
→乱数生成器を実装するトレイト。要求されるとu32を1つ返す

バディトレイトRand
→制約として別のtraitが与えられる
pub trait Rand: Sized {
    fn rand<R: Rng>(rng: &mut R) -> Self;
}

rand()に任意の乱数生成器を与えると乱数値が得られる

あるtraitが別のtraitを制約として使う
→この2つのtraitは様々な組み合わせで使える
→→関連するメソッドはジェネリックなので最適化された機械語コードを生成

11.5 制約のリバースエンジニアリング

要求を完全に満たすトレイトがない場合にジェネリックコードを書くのは本当に大変
→コンパイラをガイドとチェック機能として使った制約のリバースエンジニアリングをすることになる

ジェニリックプログラミング
→正しいトレイトを使うのが正義

制約を明示的に書くことの最大の利点
→ドキュメントに残るということ

11.6 結論

トレイトはRustを構成する主要機能の1つ
→良いインターフェイスが必要なため当然
