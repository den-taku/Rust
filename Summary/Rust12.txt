12章 演算子オーバーロード

演算子オーバーロード(operator overloading)
→独自の型に対して算術演算などの演算をサポートできる
→→いくつかの組み込みtraitを実装すれば良い

演算子オーバーロードに用いるトレイト
→いくつかのカテゴリに分類することができる

演算子オーバーロードに用いるトレイトの表はp.258

12.1 算術演算子とビット演算子

a + b
→a.add(b)の省略形に過ぎない 
→std::ops::Addトレイトのaddメソッド
→<i32 as Add>::addはi32の+演算子を関数として捉えたもの

a * b
→a.mul(b)の省略形

a - b
→a.neg(b)

関数呼び出しの形で書きたければAddトレイト(など)をスコープに入れて
その関数が見えるようにしなければならない

trait Add<RHS=Self> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}

→Add<T>はT型の値を自分に追加する能力

Rustの算術演算とビット単位演算の組み込みトレイトは3つのグループ
・単項演算子
・二項演算子
・複合代入演算子

12.1.1 単項演算子

*:参照解決演算子
-:符号反転演算子 std::ops::Neg
!:補数演算子     std::ops::Not

参照解決演算子については13.5 DerefとDerefMutで別途説明

符号付き数値型は全てstd::ops::Negを実装
整数値とbool型はstd::ops::Notを実装

12.1.2 二項演算子

二項演算子およびビット演算子と対応する組み込みトレイトの表はp.261

全ての数値型は算術演算子を実装
整数型とbool型はビット演算子を実装

表にあげられたトレイトは全て同じ形をしている
→ただしShrとShlはデフォルトがSelfにはならないので常に右辺オペランドの型を明示

Stringに&strやStringを足すことができる
→一般に文字列を組み上げるにはwrite!マクロを使った方が良い(詳細は17.3.3)

12.1.3 複合代入演算子

+=や&=など
→表はp.262

2つのオペランドを取り演算結果を左辺オペランドに格納する
→複合代入式の結果は常に()を返す

trait AddAssign<RHS=Self> {
    fn add_assign(&mut self, RHS);
}
→ShlAssignとShrAssignは自身がデフォルトの右辺オペランドの型にならない

全ての数値型は算術複合代入演算子を実装
整数型とbool型はビット単位複合代入演算子を実装

二項演算子と複合代入演算子は完全に独立している

12.2 等価性テスト


















































































