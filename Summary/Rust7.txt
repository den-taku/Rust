7章 エラー処理

panicとResultについて説明する

通常のエラー処理
→Resultを用いる
→→プログラムの外部要因に起因する

通常出ないエラー
→パニックで処理される
→→これは起こってはいけない種類のエラー

7.1 パニック

プログラム自身のバグに起因すると思われるバグ
→パニックが生じる
→→プログラマがpanic!()マクロでパニックを直接起こすこともできる

panic発生時
→２つの選択肢

・スタックを巻き戻す←デフォルト
・プロセスをアボートする

7.1.1 スレッドの巻き戻し

panic発生時の流れ

・エラーメッセージが端末に表示される
・スタックが巻き戻される
・最後にスレッドが終了する

RUST_BACKTRACE=1 cargo runと実行すればスタックのダンプも表示される
スタックが巻き戻されるされる時各値は作られたのと逆順にドロップしていく
→詳細は13.1 Dropで ユーザ定義drop関数も呼び出される
パニックを起こしたスレッドがメインスレッドだった場合プロセスが終了(終了コード0)

panicはクラッシュではないし未定義動作でもない
→panicはメモリ安全
→スレッド単位で発生する
→→19章で子スレッドのパニックを親スレッドからうまく扱う方法を示す

スタックの巻き戻しをキャッチしスレッドを殺さずに実行することもできる
→std::panic::catch_unwind()を用いる
(この機能は非Rustのコードから呼び出されるコードで必須→21章で)

catch_unwind()を使ってパニック処理することで頑健なプログラムに
→これらはスタックを巻き戻すパニックだけにしか使えない

7.1.2 アボート

abortするのは次のふた通り
・パニックを起こして巻き戻している最中に.drop()で2つ目のpanicが起きる
・コンパイル時に -C panic=abortと指定する

通常のRustのコードはpanicを処理する義務を負わない

7.2 Result

Rustには例外がない
→失敗する可能性のある関数は返り値の型でそのことを示す

Result型
成功結果Ok(v)かエラー結果Err(e)を返す
→定義は10章で

Result型を返す関数にはなんらかのエター処理を行うことを求める
→何もしないでv(値)に到達することはできない

7.2.1 エラーの補足

最もしっかりとResultを扱う
→match式を使う
→→他言語のtry/catch構文に相当
→→少し冗長になる

様々なケースに対応したメソッドがResult<T, E>には用意されている
→これらは全てmatch式で実装されている
→完全なリストはドキュメントを参照

result.is_ok()、result.is_err():
resultの成否をboolで返す

result.ok():
成功した場合の値をOption<T>として返す(Some(success_value) or None)

result.err():
失敗した場合の値をOption<Err>として返す

result.unwrap_or(fallback):
result成功->成功値、失敗->デフォルト値fallback

result.unwrap_or_else(fallback_fn):
result.unwrap_or(fallback)とほぼ同じだが関数かクロージャを渡す。処理を必要時に

result.unwrap():
成功時には成功値を返す。失敗時にはパニックを起こす

result.expect(message):
.unwrap()とほぼ同じだがpanic時にメッセージを指定できる

Resultの中の値への参照を借用するメソッドを2つ紹介

result.as_ref():
成功値またはエラー値をresultから借用してResult<T, E>をResult<&T, &E>に変換

result.as_mut():
ほとんど同じだが可変借用を借用する Result<&mut T, &mut E>

→.is_ok()、.is_err()以外はresultを消費してしまう(selfを値として引数にとる)
→.as_ref()、.as_mut()はresultを壊さずに取り出せる
→→result.as_ref().ok()のようにすることで値を壊さずに扱える

7.2.2 Result型のエイリアス

エラー型のないResult型Result<()>
→Result型のエイリアスが使われている

型エイリアス:
型名の省略形。エラー型を省略して利用できる

7.2.3 エラーの伝搬

多くの場合起きたエラーの処理は呼び出しもとに任せたい
→つまり呼び出しスタックを遡って伝搬させたい

?演算子
→Result型を生成する任意の式に対して伝搬をサポート

?の挙動は成否に依存して変化する

成功時
→Resultを用いて中の成功値を取り出す

失敗値
→呼び出し元の関数から即時リターンし呼び出し連鎖上流の関数にエラーを渡す
→→返り値がReturn型の関数内部でしか利用できない

let wether = match get_wether(hometown) {
    Ok(success_value) => success_value,
    Err(err) => return Err(err)
};
→わずかに?演算子とは挙動が異なる

try!()マクロ
→?演算子導入以前によく用いられたエラー伝搬方法
→上に示すmatch式に変換される

OSに関わるコードではどこでもエラーが生じ得るので?がいっぱい!

7.2.5 複数種類のエラーへの対応

複数種類のエラーが返ってくる場合

・各エラー型から独自定義型へ変換を実装(error-chain crate等)

・stlのエラー型を全て変換可能なBox<std::error::Error>に変換
→呼び出し側が予期しているエラーが厳密には何なのかを表現する方法がなくなる

?演算子は自動変換を標準メソッド::from()を用いて行う
13章でFromトレイトとfrom()メソッドについて詳しく説明する

特定の種類のエラーだけ対処して残りは上に伝搬させたい
→error.downcast_ref::<ErrorType>()を使う
多くの言語は構文としてこれを持つがRustはメソッドとして用いる

7.2.6 「起こるはずのない」エラーの処理

起こるはずのないエラーの処理を書かなくてはいけないときもある

例えば.unwrap()や.expect(message)を使う
→実際に起こってしまった時にはパニックを起こす

7.2.7 エラーを無視する

Result型を使われないと警告を表示する
→let _ = ...;のように書くと良い

7.2.8 main()でのエラー処理

エラーを伝搬し続けると最後はmain()関数にたどり着く
→main()の返り値はResultではないので?演算子は使えない

.expect()を使うのが最も単純な方法
→パニックを起こし0でない終了コードでプロセスを終了する

if let Err(err) = calculate_tides() {
    print_error(&err); // <- 7.2.3
    std::process::exit(1)
}
→自分でエラーメッセージを出力してノイズに埋もれるのを避ける
→→if let式の詳細は10章

7.2.9 カスタムエラー型の宣言

ユーザ定義型は次章以降

json/src/error.rsのJsonError構造体
→json::error::JsonError

7.2.10 なぜResultを使うのか

・エラーの無視ができない
・エラーの伝搬が?演算子だけで扱える
・失敗する可能性のある関数とそうでないものを明確に分ける
・Resultはデータ型なので結果を同じコレクションに格納できる

多くのプログラマが慣れ親しんだエラー処理よりもほんの少し厳密
