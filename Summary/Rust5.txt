5章　参照

参照(reference):
所有権を持たないポインタ型
→ある値に対する参照を作ること:借用(borrowing)
→参照は参照先よりも長生きしてはならない

参照を安全に保つルールがRust固有

Hash<String, Vec<String>>:
StringをVec<String>値にマップするハッシュテーブル

参照には2種類ある

共有参照(shared reference):
readonlyな参照。同時に何個からでも参照できる。Copy型。

可変参照(mutable reference):
値の読み出し・変更が可能な参照。他の参照から使用不可。非Copy型。

→複数読み出しか単一書き込みのルール
→→ある値に対する可変参照は排他的なアクセス権を持つ

共有参照に対するforループ
→各要素への共有参照を作るようになっている

値渡し(pass by value): 所有権を移動
参照渡し(pass by reference): 参照を渡す

5.1 値としての参照

参照の柔軟な使い方の例を見る

5.1.1 Rustの参照 vs C++の参照

C++
→暗黙に参照が作られ参照解決も暗黙
Rust
→明示的に参照を作り(&)、参照解決も明示的(*)
→→可変参照は&mutで作る

ただしRustでは.演算子が必要なら暗黙に左オペランドを参照解決する

5.1.2 参照の代入

let mut x
→参照への代入では参照するアドレスを変更できる
→→C++とは挙動が異なるので注意

5.1.3 参照への参照

Rustは参照への参照を許す

5.1.4 参照の比較

.演算子と同様に比較演算子も何段も参照解決を行える

==は値が等しいかを確認する
→同じ値を指しているかを知りたければstd::ptr::eqを使えば良い

5.1.5 参照はヌルにならない

Rustの参照は決してnullにならない
→C++と同等に効率的でより安全になっている

値の存在が不確定なもの
→Opition<&T>を用いる
→→None:ヌルポインタ(機械語のレベル)
→→Some(r):0以外のアドレス(rは&T型)

5.1.6 任意の式への参照の借用

Rustでは任意の式の値に対して参照を借用できる

&numberic_literal
→無名変数を作り参照がそれを指すようにする(生存期間は何をするかに依存)

・let文等ですぐに代入→初期化した変数の生存期間と同じ
・それ以外では無名変数をくるんでいる文の終わりまで

無名変数の死後に参照を使おうとするとコンパイルエラー

5.1.7 スライスとトレイトオブジェクトへの参照

Rustには2種類のファットポインタ(fat pointer)がある
→なんらかの値へのアドレスと、それを使うのに必要な情報を持つ

スライスへの参照:
スライスの開始点のアドレスと長さを持つファットポインタ

5.2 参照の安全性

この方法ではRustの制御(制約)方法をみる

5.2.1 ローカル変数の借用

ローカル変数を借用してスコープ外には持ち出せない

Rust
→全ての参照方に対して使われ方によって生じる生存期間(lifetime)を割り当てる
→→生存期間:安全に利用できる期間(コンパイラによって想定)
→→実行時には参照はただのアドレスにすぎない

・変数xから借用した参照の生存期間⊂変数xの生存期間
・参照&yを格納した変数の生存期間⊂&yの生存期間
→Rustはこの２つの制約を満たす生存期間を探す

同様に参照を他のデータ構造に格納する場合
→各参照の生存期間がデータ構造の生存期間を包含しなければならない

他の制約も、基本的にな原理はこの制約と変わらない

5.2.2 仮引数として参照を受け取る場合

static:
グローバル変数に該当。プログラムの実行開始時に作られ終了するまで維持される
→生存期間がグローバル(見える範囲はmodule systemが管理)(詳しくは8章)
→→'static生存期間

生存期間'a(「tick A」):
fの生存期間パラメータ

<'a>:
任意の生存期間'aに対して

関数のシグニチャ
→常にボディの挙動を明らかにするようにする
→→例えば引数の参照をどこかのグローバル変数に隠すような関数は(&'static T)で表記

5.2.3 参照を引数として渡す

生存期間パラメータの心配
→関数や型を定義するときだけ
→→使用するときのエラーはコンパイルが制御

5.2.4 返り値としての参照

fn smallest<'a>(v: &'a [i32]) -> &'a i32 {...}
→引数と返り値が同じ生存期間

5.2.5 参照を含む構造体

参照型が他の型の定義に含まれている
→生存期間を明示的に書かなければならない

別の構造体の中に隠しても生存期間の宣言は必要
→S<'static>のように生存期間を与えることもできる
→→Tを借用する側にだけ制限が生じる

Rustではあらゆる型が生存期間をもつ
→多くの場合は'staticだが'aのように制限がつくものもある(参照などで)

5.2.6 個別の生存期間パラメータ

各要素に独立した複数の生存期間を与えることができる
→増やしすぎると型や関数のシグニチャが読みづらくなるので注意

(Rustは可能な限り短い生存期間を選ぼうとする)

5.2.7 生存期間パラメータの省略

生存期間は自明な場合省略可能

関数が生存パラメータを持つ値を返さない場合
→必要な場所にそれぞれ独立な生存期間を割り振る

生存パラメータを持つ値を返す場合
→曖昧さがない場合はコンパイラが補完

→仮引数に生存期間が１つ
→→全ての返り値の生存パラメータをその値にする

→仮引数に生存期間が複数
→→明示的に書くことを求める
→→→ただし関数が型に対するメソッドでself仮引数を参照で取る場合はこれを優先

メソッドに関しては9.5 implによるメソッド定義で

5.3 共有と変更

参照しつつ同時に変更することは多くの言語で難しい領域
→Rustでは共有参照と可変参照の生存期間が重なることを厳密に禁止する

・共有アクセスはReadOnly
 →直接の参照先のみならず派生先全てはどのような方法でも変更できない

・可変アクセスは排他アクセス
 →派生先も全て他のパスから参照できない。可変参照から借用した参照だけが重複可

P115 図5-9 参照すべし

共有参照から
→共有参照を借用:可能
→可変参照を借用:不可

可変参照から
→共有参照を借用:不可
→可変参照を借用:可能

変更アクセスを排他的にすることで様々なバグを避けることができる
(Cのconstポインタよりも厳格)

5.3.1 オブジェクトの海に立ち向かう

1990年代に自動的なメモリ管理が興隆してから、
全てのプログラムはオブジェクトの海(sea of object)を基本構造とするようになった
→Rustは相互参照サイクル構造を作りづらいようになっているので阻止できる

