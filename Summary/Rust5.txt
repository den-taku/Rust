5章　参照

参照(reference):
所有権を持たないポインタ型
→ある値に対する参照を作ること:借用(borrowing)
→参照は参照先よりも長生きしなければならない

参照を安全に保つルールがRust固有

Hash<String, Vec<String>>:
StringをVec<String>値にマップするハッシュテーブル

参照には2種類ある

共有参照(shared reference):
readonlyな参照。同時に何個からでも参照できる。Copy型。

可変参照(mutable reference):
値の読み出し・変更が可能な参照。他の参照から使用不可。非Copy型。

→複数読み出しか単一書き込みのルール
→→ある値に対する可変参照は排他的なアクセス権を持つ

共有参照に対するforループ
→各要素への共有参照を作るようになっている

値渡し(pass by value): 所有権を移動
参照渡し(pass by reference): 参照を渡す

5.1 値としての参照

参照の柔軟な使い方の例を見る

5.1.1 Rustの参照 vs C++の参照

C++
→暗黙に参照が作られ参照解決も暗黙
Rust
→明示的に参照を作り(&)、参照解決も明示的(*)
→→可変参照は&mutで作る

ただしRustでは.演算子が必要なら暗黙に左オペランドを参照解決する

5.1.2 参照の代入

let mut x
→参照への代入では参照するアドレスを変更できる
→→C++とは挙動が異なるので注意

5.1.3 参照への参照

Rustは参照への参照を許す

5.1.4 参照の比較

.演算子と同様に比較演算子も何段も参照解決を行える

==は値が等しいかを確認する
→同じ値を指しているかを知りたければstd::ptr::eqを使えば良い

5.1.5 参照はヌルにならない

Rustの参照は決してnullにならない
→C++と同等に効率的でより安全になっている

値の存在が不確定なもの
→Opition<&T>を用いる
→→None:ヌルポインタ(機械語のレベル)
→→Some(r):0以外のアドレス(rは&T型)

5.1.6 任意の式への参照の借用

Rustでは任意の式の値に対して参照を借用できる

&numberic_literal
→無名変数を作り参照がそれを指すようにする(生存期間は何をするかに依存)

・let文等ですぐに代入→初期化した変数の生存期間と同じ
・それ以外では無名変数をくるんでいる文の終わりまで

無名変数の死後に参照を使おうとするとコンパイルエラー

5.1.7 スライスとトレイトオブジェクトへの参照

Rustには2種類のファットポインタ(fat pointer)がある
→なんらかの値へのアドレスと、それを使うのに必要な情報を持つ

スライスへの参照:
スライスの開始点のアドレスと長さを持つファットポインタ

5.2 参照の安全性

この方法ではRustの制御方法をみる

5.2.1 ローカル変数の借用

ローカル変数を借用してスコープ外には持ち出せない

Rust
→全ての参照方に対して使われ方によって生じる生存期間(lifetime)を割り当てる
→→生存期間:安全に利用できる期間(コンパイラによって想定)
→→実行時には参照はただのアドレスにすぎない

・変数xから借用した参照の生存期間⊂変数xの生存期間
・参照&yを格納した変数の生存期間⊂&yの生存期間
→Rustはこの２つの制約を満たす生存期間を探す

同様に参照を他のデータ構造に格納する場合
→各参照の生存期間がデータ構造の生存期間を包含しなければならない

他の制約も、基本的にな原理はこの制約と変わらない






























































































