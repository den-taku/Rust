6章　式

本章はRust関数のボディ部を構成する式(expression)について説明する
→クロージャやイテレータなどは後で章を設けて説明

6.1 式言語

Cでは式(expression)と文(statement)が厳密に区別されている
→式には値があり、文にはない
→制御フローはほぼ文

Rustはいわゆる式言語(expression language)の１つ
→全て式なので値を作ることができる
→→ifやmatchを初期化や引数に使える

if文がそのまま使えるので三項演算子がない

6.2 ブロックとセミコロン

Rustではブロック{...}も式

;で終了→()を返す
}で終了→最後の値を返す

;を抜かしてしまった時のエラーメッセージがわかりづらい
→expected type'()'とか

Rustは空文(empty statements)を許す
loop {
    work();
    play();
    ; // <-- empty statement
}

6.3 宣言

ブロックには式とセミコロン以外に任意の数の宣言を書くことができる

let name: type = expr;
→セミコロンは必須
→宣言だけして後から初期化することもできる

２つ目の変数に１つめと同じ名前をつけるのは許されている

ブロック内でアイテムの宣言(item declaration)を行うこともできる
→アイテム:fn、struct、useなどのもの
→→スコープはブロック内
→→→ただしそのスコープ内の別のローカル変数を直接利用することはできない
→→→→外側のスコープを見ることができるクロージャは14章で

6.4 ifとmatch

if condition1 {
    block1
} else if condition2 {
    block2
} else {
    block_n
}

else ifもelseも省略可能
→ない場合はからのelseブロックがあった場合と同じ挙動

全てのブロックは同じ型の値を生成しなくてはならない

match value {
    pattern => expression,
    ...
}

valueに対し個々のパターンを上から順に適応していきマッチするとexprを評価して終了
→全てのケースをカバーしていないmatch式は許されない

_はワイルドカード

コンパイラはこの種のmatch式をジャンプテーブルにコンパイルして最適化
定数値を返すときは定数値の配列を作り添字を与える

patternには様々なものが使える→詳細は10章で

expressionがブロックの時は分岐最後のカンマは省略可

match式の分岐も全て同じ値でなくてはいけない

6.4.1 if let式

if let pattern = expr {
    block1
} else {
    block2
}

与えられたexprがpatternにマッチするならblock1が実行されしなければblock2が実行
OptionやResultからデータを取り出すのに便利

if let式を使う厳密な必要性はない(match式でもできるので)

6.5 ループ

Rustには４つのループ式がある

while condition {
    block
}

while let pattern = expression {
    block
}

loop {
    block
}

for pattern in collection {
    block
}

ループの値は常に()

loopは無限ループ
→breakやreturnに到達するか、スレッドがパニックを起こすまで

forループはcollection式を評価し、collectionに含まれる各値に対してblockを実行
→様々なコレクション型をサポートしている

..演算子:
範囲(range)を生成する
→0..20とstd::ops::Range { start: 0, end: 20}は同じ意味
→→範囲はstd::iter::IntoIteratorを実装しているイテレート可能型(iterable)

標準的なコレクションは全てイテレート可能となっている
→→→詳しくは15章で

値をforでループすると移動されてドロップされる
→コレクションの参照に対してループすれば良い
→→&mutを渡すこともできる

forループに関しては15章で詳しく説明する

break式はループ式の中でしか機能しない
continue式を用いるとループの次の回に飛ぶ　

ループに生存期間でラベル付け(labeled)することができる
→break 'a;で'aの生存期間を持つループを中断できる
→→continueにも使える(外側のコレクションを１つ進める)

6.6 return式

return式:
現在の関数から脱出し、値を呼び出し元に返す
→値のないreturnはreturn()の省略形

?演算子:
Hoge(v)? → 以下のコードの省略
let name = match Hoge(v) {
    Ok(a) => a,
    Err(err) => return Err(err)
};
→→詳しくは7.2.4 エラーの伝搬で説明

6.7 なぜRustにはloop式があるのか

Rustは様々な観点でプログラムの制御フローを解析する
・関数のすべてのパスが期待される返り値を返す
・変数を初期化せずにはどこでも使えない
・到達できないコードは警告
→関数のすべてのパスをチェックする必要がある

→フローを考慮した解析と呼ばれる
→→これはループの条件を全く考慮せずに解析する

!(never)型:
値を返さない型
→型が合致しなくてはならないというルールが適用されない

fn exit(code: i32) -> !
→発散する関数(divergent function)で値が返ってこない

loopやreturn、breakなどは通常のフロー通りに流れない
→これらの式は通常の型を持たない

6.8 関数呼び出しとメソッド呼び出し

let x = gcd(1302, 462); // function call
let room = player.location(); // method call
let mut numbers = Vec::new(); // static method call

独自のメソッドを定義する方法は9章でユーザ定義型の説明時に

.演算子は参照解決をする
→メソッド呼び出しは参照でも参照のさす値でも同じ結果

static method
→型に対して呼ばれる
non static method
→値に対して呼ばれる

メソッドは連鎖させることができる

呼び出しでは通常のジェネリック型(Vec<T>とか)の構文が使えない
→比較演算子<、>と区別がつけられないから
→→Vec<T> → Vec::<T>のように書く

シンボル::<...>はターボフィッシュ(turbofish)と呼ばれる(愛を込めて)

型パラメータを省略してコンパイラに推論させることもできる場合がある

6.9 フィールドと要素

構造体のフィールド
→馴染み深い構文でアクセスできる

タプルのフィールド
→名前ではなく番号がついている

配列やスライスうやベクタの要素
→大括弧[]を用いる
→→大括弧の左側の値も自動的に参照解決される

↑この３つの式は代入文の左辺に現れることができるので左辺値(lvalue)と呼ばれる

スライスを取り出すのは簡単([]を使う)

..演算子はどちらのオペランドも省略できる

..    // RangeFull
a..   // RangeFrom{ start: a }
..b   // RangeTo{ end : b }
a..b  // Range{ start: a, end: b }

→Rustの範囲は半開区間(half-open) : [a,b)

配列のスライスは上記４つの形が利用できる

6.10 参照演算子

演算子&と&mutについては5章ですでに述べた
単項演算子*は参照で指される値にアクセスするために用いられる
→*演算子が必要になるのは参照がさす値全体を読み書きする場合など

6.11 算術演算子、ビット演算子、比較演算子、論理演算子

通常の算術演算子+、-、*、/、%など
→デバッグビルドでは整数のオーバーフローは検出されパニックになる
→→オーバーフローをチェックしないa.wrapping_add(b)などがSTLにはある
→→整数をゼロで割るとリリースビルドでもパニックになる

単項演算子-
→正負を反転する。符号なしを除く全ての数値型をサポート

%演算子:
剰余を計算。結果は左オペランドと同じ符号。浮動小数点数にも利用可能
(ただしおよその値を返す)

bit演算子&、|、^、<<、>>はCと同じ
bit反転→~ではなく!を用いる
→bitシフトは符号の有無しで符号拡張またはゼロ拡張を行う

Rustでは比較演算よりもbit単位演算の方が高い順位を持つ

比較演算子==、!=、<、<=、>、>=

ショートカットを行う２つの演算子&&と||がある

6.12 代入

=演算子
→代入するために用いられる(非Copy型は値を移動する)

複合代入演算子+=や=+などもサポートされている

インクリメント++、デクリメント--はない

完全なリストはP138をチェック

6.13 型キャスト

型変換
→通常はas演算子を用いて明示的にキャストする

キャストにはいくつかの種類がある

・組み込み数値型の間ではキャストが可能
・bool、char、enumからは任意の整数型にキャスト可。逆は基本不可
・安全でないポインタ型に関連するキャスト→21.7 rawポインタを参照

単純な型変換はキャストなしで行えるものもある
→Deref自動変換(delef coercions)と呼ばれる
→→組み込みトレイトのDerefを実装している型に適用される
→→→参照先の値と可能な限り同じように振る舞わせることが目的

独自のスマートポインタ型を書く必要があるなら13.5 DerefとDerefMutを見ること

6.14 クロージャ

クロージャ(closure):
軽量の関数のような値

||で囲まれた引数リストと式で構成される
コンパイラが引数と返り値の型を推論してくれるが明示的にもかける

let is_even = |x| x % 2 == 0;
let is_even = |x: u64| -> bool { x % 2 == 0 };

クロージャは14章で説明する

6.15 優先順位と結合性

演算子には優先順位がある→P138

連鎖する演算子(* / % + - >> << & ^ | && || as) → 左結合

6.16 その先へ

式:
「実行するコード」と考えるもの
→言語全体から見るとごく一部でしかない
