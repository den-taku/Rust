6章　式

本章はRust関数のボディ部を構成する式(expression)について説明する
→クロージャやイテレータなどは後で章を設けて説明

6.1 式言語

Cでは式(expression)と文(statement)が厳密に区別されている
→式には値があり、文にはない
→制御フローはほぼ文

Rustはいわゆる式言語(expression language)の１つ
→全て式なので値を作ることができる
→→ifやmatchを初期化や引数に使える

if文がそのまま使えるので三項演算子がない

6.2 ブロックとセミコロン

Rustではブロック{...}も式

;で終了→()を返す
}で終了→最後の値を返す

;を抜かしてしまった時のエラーメッセージがわかりづらい
→expected type'()'とか

Rustは空文(empty statements)を許す
loop {
    work();
    play();
    ; // <-- empty statement
}

6.3 宣言

ブロックには式とセミコロン以外に任意の数の宣言を書くことができる

let name: type = expr;
→セミコロンは必須
→宣言だけして後から初期化することもできる

２つ目の変数に１つめと同じ名前をつけるのは許されている

ブロック内でアイテムの宣言(item declaration)を行うこともできる
→アイテム:fn、struct、useなどのもの
→→スコープはブロック内
→→→ただしそのスコープ内の別のローカル変数を直接利用することはできない
→→→→外側のスコープを見ることができるクロージャは14章で

6.4 ifとmatch

if condition1 {
    block1
} else if condition2 {
    block2
} else {
    block_n
}

else ifもelseも省略可能
→ない場合はからのelseブロックがあった場合と同じ挙動

全てのブロックは同じ型の値を生成しなくてはならない

match value {
    pattern => expression,
    ...
}

valueに対し個々のパターンを上から順に適応していきマッチするとexprを評価して終了
→全てのケースをカバーしていないmatch式は許されない

_はワイルドカード

コンパイラはこの種のmatch式をジャンプテーブルにコンパイルして最適化
定数値を返すときは定数値の配列を作り添字を与える

patternには様々なものが使える→詳細は10章で

expressionがブロックの時は分岐最後のカンマは省略可

match式の分岐も全て同じ値でなくてはいけない

6.4.1 if let式

if let pattern = expr {
    block1
} else {
    block2
}

与えられたexprがpatternにマッチするならblock1が実行されしなければblock2が実行
OptionやResultからデータを取り出すのに便利

if let式を使う厳密な必要性はない(match式でもできるので)

6.5 ループ

Rustには４つのループ式がある

while condition {
    block
}

while let pattern = expression {
    block
}

loop {
    block
}

for pattern in collection {
    block
}

ループの値は常に()

loopは無限ループ
→breakやreturnに到達するか、スレッドがパニックを起こすまで

forループはcollection式を評価し、collectionに含まれる各値に対してblockを実行
→様々なコレクション型をサポートしている

..演算子:
範囲(range)を生成する
→0..20とstd::ops::Range { start: 0, end: 20}は同じ意味
→→範囲はstd::iter::IntoIteratorを実装しているイテレート可能型(iterable)

標準的なコレクションは全てイテレート可能となっている
→→→詳しくは15章で

値をforでループすると移動されてドロップされる
→コレクションの参照に対してループすれば良い
→→&mutを渡すこともできる

forループに関しては15章で詳しく説明する

break式はループ式の中でしか機能しない
continue式を用いるとループの次の回に飛ぶ　

ループに生存期間でラベル付け(labeled)することができる
→break 'a;で'aの生存期間を持つループを中断できる
→→continueにも使える(外側のコレクションを１つ進める)

6.6 return式

return式:
現在の関数から脱出し、値を呼び出し元に返す
→値のないreturnはreturn()の省略形

?演算子:
Hoge(v)? → 以下のコードの省略
let name = match Hoge(v) {
    Ok(a) => a,
    Err(err) => return Err(err)
};
→→詳しくは7.2.4 エラーの伝搬で説明

6.7 なぜRustにはloop式があるのか

Rustは様々な観点でプログラムの制御フローを解析する
・関数のすべてのパスが期待される返り値を返す
・変数を初期化せずにはどこでも使えない
・到達できないコードは警告
→関数のすべてのパスをチェックする必要がある

→フローを考慮した解析と呼ばれる
→→これはループの条件を全く考慮せずに解析する

!(never)型:
値を返さない型
→型が合致しなくてはならないというルールが適用されない

fn exit(code: i32) -> !
→発散する関数(divergent function)で値が返ってこない

loopやreturn、breakなどは通常のフロー通りに流れない
→これらの式は通常の型を持たない



























































































































































































