20章 マクロ

Rustはマクロ(macro)機能をサポートしている
→関数だけではできないような言語拡張がマクロなら実現できる

マクロはある種の短縮記法
→コンパイル時に型チェックや機械コードの生成より前にマクロ呼び出しは展開される

マクロ呼び出し時には常に!をつける
→通常の関数呼び出しと混同しにくい

21.1 マクロの基本

macro_rules!はマクロを定義する際に用いる
→他にもコンパイラに組み込まれたマクロや手続きマクロなどがある

macro_rules!で定義されたマクロは完全にパターンマッチで動作する

macro_rules! macro_name {
    ($hoge1:expr, &hoge2:expr) /* pattern */ => ({
        match (&$hoge1, &$hoge2) { /* template */
            ... 
        }
    });
}

パターンやテンプレート周りの小括弧は大括弧や中括弧でも良い
→呼び出す際も同じ
→→中括弧を使えば;を省略できる

20.1.1 マクロ展開の基礎

コンパイラはソースコードを最初から最後まで読み込みマクロの定義と展開を行う
→定義前に呼び出すことはできない
→→これに対して関数やその他アイテムに順序は関係ない

マクロ呼び出しはmatch式の評価に似ている
→パターンはトークンに対して操作を行う
→→コメントやホワイトスペースはトークンでないのでパターンにいくら入れても問題ない

トークン(token):
数値や識別子、括弧などのRustプログラムを構成する要素

pattern中のカンマは引数中のカンマにマッチする

コードフラグメントexpr
→式がくることを期待する

20.1.2 意図しない結果

コンパイラはマッチした式をテンプレートに何度も埋め込む
→引数として取る値は一度だけ計算し変数に保存する

変数は参照を介して扱う
→移動を防ぐため

変数をmatchで宣言していることに意味はない
→letで宣言しても同じ結果になる

20.1.3 繰り返し

複数パターンがある場合は1つずつマッチを試みる
→マッチするルールがなかったらエラーになる

正規表現とは少し違う、繰り返しパターンで使える表現がある

$( ... )*   0個以上にマッチ。セパレータなし
$( ... ),*  0個以上にマッチ。セパレータはカンマ
$( ... );*  0個以上にマッチ。セパレータはセミコロン
$( ... )+   1個以上にマッチ。セパレータはなし
$( ... ),+  1個以上にマッチ。セパレータはカンマ
$( ... );+  1個以上にマッチ。セパレータはセミコロン

$(pattern)* 
→各要素がpatternにマッチするものがマッチする

<[_]>:
何かのスライス型を表す。型推論はRustに任される
→fn()、&str、[_]のようなものは<>で囲まなければならない

$( ... ),*を用いたパターンは最後に余分なカンマがついたリストにマッチしない

20.2 組み込みマクロ

file!():
現在のファイル名を示す文字列リテラルに展開される

line!():
現在の行番号(1スタート)を示すu32リテラルに展開される

column!():
現在のカラム位置(0スタート)を示すu32リテラルに展開される

→これらが段階を重ねて呼ばれた場合、最初にマクロが呼ばれた場所準拠になる

stringify!(...tokens...):
引数に与えたトークン列を含んだ文字列リテラルに展開される
→引数内のマクロ呼び出しは展開されない

concat!(str0, str1, ...):
引数を全て繋げた文字列リテラルに変換される

cfg!(...):
現在のビルド設定が括弧内の条件にマッチしたかどうかを表す真偽値定数に展開される

env!("VAR_NAME"):
コンパイル時に指定された環境変数の値を示す文字列に展開される
→環境変数のリストはCargoのドキュメントにある

option_env!("VER_NAME"):
Option<&'static str>を返す

include!("file.rs"):
指定したファイルの中身に展開される
→このファイルは有効なRustのコードでなければならない

include_str!("file.txt"):
指定したファイルの中身を保持した&'static strに展開される

include_bytes!("file.dat"):
バイナリデータを&'static [u8]として展開する

ファイルがなかったり読み出せなかった場合コンパイルエラーになる

ファイル名は相対パスで解釈される

20.3 マクロのデバッグ

マクロのデバッグは大変
→マクロの問題を解決する際に利用できる3つの道具ある

1.
全てのマクロを展開したコードを表示するようにrustcに指定できる
→Nightly Rustでしか使えない

・rustup override add nightly (rustup ovverride set nightlyでもいけそう)
・cargo build --verboseでrustcのオプションを確認する
・-Z unstable-options --pretty expandedを追加する

2.
log_syntax!()マクロを使う
→コンパイル時に引数を端末に表示する
→→機能フラグ#![feature(log_syntax)]が必要

3.
trace_macros!(true)をどこかに書いておけば全てのマクロ呼び出しを表示する

20.4 json!マクロ

ここではマクロ開発の仕方とmacro_rules!の未説明部分を説明していく

20.4.1 フラグメント型

複雑なマクロを書くときに最初にすること
→想定する入力に対してマッチもしくパースする方法を見つけること

exprはRust式とマッチするので独自定義型はマッチしない

macro_rules!でサポートされているフラグメント型(詳細はp495の表20-1)

expr  式
stmt  式もしくは宣言。最後のセミコロンは含まない
ty    型
path  パス
pat   パターン
item  アイテム
block ブロック
meta  属性のボディ部
ident 識別子
tt    トークンツリー

ほとんどのフラグメント型はRust構文に厳密に従い拡張できない
→identとttはRustコードに見えないようなマクロ引数にもマッチする

各フラグメントに対してその直後に現れる事のできるトークンは制限されている

20.4.2 マクロ中の再帰

マクロ中で自分自身を呼び出し再帰的に処理することができる

マクロの再起呼び出しはデフォルトで64回までと制限されている
→#![recursion_limit = "num"]で上限を調整できる

20.4.3 マクロでのトレイトの利用

Fromトレイトを使えば様々な型の値を特定の型に変換できる

トレイトを使ってマクロを構成することもできる

20.4.4 スコープと健全マクロ

マクロは異なるスコープに存在するコードを貼り合わせる
→一時変数と名前がかぶる可能性がある

Rustには健全マクロ(hygienic macros)がある
→コンパイラが自動的に変数名の変更を行う
→→マクロから展開された部分のみ色付けされるようなもの
→→色付けされるのはローカル変数、引数のみ

健全化を意図的に避けたい場合
→マクロコードの内外で使用する識別子を全てマクロの引数として渡せば良い

20.4.5 マクロのインポートとエクスポート

マクロはコンパイルの早い段階で展開される
→モジュール構成を完全に把握する前なので通常の方法でimport、exportできない

単一のクレート内では

・あるモジュールで見えているマクロは自動的にその子モジュールでも見える
・親モジュールでマクロをエクスポートするには#[macro_use]属性を用いる

複数のクレートを使う場合は

・他のクレートのマクロをインポートするにはextern crate宣言に#[macro_use]をつける
・クレート内のマクロをエクスポートするにはpublicなmacroに#[macro_export]を付与する

従ってexportされたマクロは何かがスコープに入っていることに依存してはいけない
→使用する名前を常に絶対パスで書くようにする
→→macro_reles!は特殊フラグメント$crateを提供する
→→→これはマクロが定義されているクレートのルートモジュールへの絶対パスのように振る舞う

$crate::Jsonや$crate::macro::HashMapのようにかける
→HashMapはpubキーワードで再エクスポートする必要がある

20.5 マッチ中のシンタックスエラーを避ける

フラグメントにマッチを試みる際にシンタックスエラーが発生することがある
→シンタックスエラーは無視されない

・全てのパターンが異なる識別子から始まるようにする
・より特定的なルールを先に書く

などで回避する必要がある

20.6 macro_rules!の先






































































