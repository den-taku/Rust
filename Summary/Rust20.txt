20章 マクロ

Rustはマクロ(macro)機能をサポートしている
→関数だけではできないような言語拡張がマクロなら実現できる

マクロはある種の短縮記法
→コンパイル時に型チェックや機械コードの生成より前にマクロ呼び出しは展開される

マクロ呼び出し時には常に!をつける
→通常の関数呼び出しと混同しにくい

21.1 マクロの基本

macro_rules!はマクロを定義する際に用いる
→他にもコンパイラに組み込まれたマクロや手続きマクロなどがある

macro_rules!で定義されたマクロは完全にパターンマッチで動作する

macro_rules! macro_name {
    ($hoge1:expr, &hoge2:expr) /* pattern */ => ({
        match (&$hoge1, &$hoge2) { /* template */
            ... 
        }
    });
}

パターンやテンプレート周りの小括弧は大括弧や中括弧でも良い
→呼び出す際も同じ
→→中括弧を使えば;を省略できる

20.1.1 マクロ展開の基礎

コンパイラはソースコードを最初から最後まで読み込みマクロの定義と展開を行う
→定義前に呼び出すことはできない
→→これに対して関数やその他アイテムに順序は関係ない

マクロ呼び出しはmatch式の評価に似ている
→パターンはトークンに対して操作を行う
→→コメントやホワイトスペースはトークンでないのでパターンにいくら入れても問題ない

トークン(token):
数値や識別子、括弧などのRustプログラムを構成する要素

pattern中のカンマは引数中のカンマにマッチする

コードフラグメントexpr
→式がくることを期待する

20.1.2 意図しない結果

コンパイラはマッチした式をテンプレートに何度も埋め込む
→引数として取る値は一度だけ計算し変数に保存する

変数は参照を介して扱う
→移動を防ぐため

変数をmatchで宣言していることに意味はない
→letで宣言しても同じ結果になる

20.1.3 繰り返し

複数パターンがある場合は1つずつマッチを試みる
→マッチするルールがなかったらエラーになる

正規表現とは少し違う、繰り返しパターンで使える表現がある

$( ... )*   0個以上にマッチ。セパレータなし
$( ... ),*  0個以上にマッチ。セパレータはカンマ
$( ... );*  0個以上にマッチ。セパレータはセミコロン
$( ... )+   1個以上にマッチ。セパレータはなし
$( ... ),+  1個以上にマッチ。セパレータはカンマ
$( ... );+  1個以上にマッチ。セパレータはセミコロン

$(pattern)* 
→各要素がpatternにマッチするものがマッチする

<[_]>:
何かのスライス型を表す。型推論はRustに任される
→fn()、&str、[_]のようなものは<>で囲まなければならない

$( ... ),*を用いたパターンは最後に余分なカンマがついたリストにマッチしない

20.2 組み込みマクロ
































































































