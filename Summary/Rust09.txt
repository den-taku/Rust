9章 構造体

構造体(struct):
様々な型の複数の値を1つの単位として扱えるように1つの値に組み込んだもの
→構成要素に愛する操作を行うメソッドを関連づけることもできる

Rustには3種類の構造体
・名前付きフィールド型
・タプル型
・ユニット型
→個々の要素にアクセスする方法が異なる

9.1 名前付きフィールド型構造体

名前付きフィールド型構造体の定義式

struct StructName {
    key1: type,
    key2: type,
    ...
}

構造体を含む全ての型の名前はCamelCaseで書く
フィールド名やメソッド名はsnake_caseで書く

この型の値を生成するには次のような構造体式を用いる

let name = StructName {
    key1: value1,
    key2: value2,
    ...
};

省略形(フィールド名と同じ変数や引数を用いて)
StructName { key1, key2, .. .}
→key: value構文と省略形を組み合わせることもできる

module内ではdefaultでprivate
→構造体、各フィールドを外から使うにはpubキーワードをつける
→privateフィールドがあると構造体式(通常の宣言式)で宣言できない

StringやVecは構造体だがフィールドがprivateなので構造体式で宣言できない

省略したフィールドを同じ型の他の構造体を使って指定することもできる
→..式を用いて行う
→指定しなかったフィールドが..以降の構造体の値から取られる

9.2 タプル型構造体

タプルに似ているのでタプル型構造体と呼ばれる

struct Name(type0, type1, ...)

タプルとの違いは構造体名を与えなければならないということ

要素(element):
タプルまたはタプル型構造体に格納できる値

個々の要素をpublicにもprivateにもできる

型を定義すると関数が自動的に定義される
fn Name(elem0: type0, elem1: type1, ...) -> Name {...}

名前付きフィールド型構造体とタプル型構造体はよく似ている
→読みやすさ・曖昧さ・簡潔さの問題

タプル構造体
→新しい型を作るのに便利(構成要素が1つだけの構造体)
→→効率的な型変換は21章で

9.3 ユニット型構造体

全く要素を宣言しない構造体

struct Name;

ユニット型()と同じようにメモリを消費しない

式..(範囲演算子)はUnit型構造体RangeFull値の短縮系

Unit型構造体はtraitを扱う際にも役立つ→11章

9.4 構造体のレイアウト

メモリ上では名前付きフィールド型構造体とタプル型構造体は同じ
→ただしフィールドや要素の配置順に規定がない
→構造体のメモリブロックにフィールドの値が直接置かれることは保証されている

#[repr(C)]属性をつければC++と互換性のある配置になる→21章で詳しく

9.5 implによるメソッド定義

任意の独自に定義した構造体に対してメソッドを定義できる
→構造体の外のimplブロック中に書く

implブロックはfnによる関数定義の集合

method
→特定の型に関連づけられているので関連づけられた関数(associated function)とも
→対をなすのは自由関数(free function)

構造体のフィールド
→明示的にselfを使って参照する
→→呼び出し時はメソッド呼び出し機構が暗黙に借用するので省略可能
→→→q.push(...)のように書くだけで(&mut q).push(...)と同じに

selfの所有権を取得したい時
→selfを値で受けることもできる
→もちろん所有権は移動する

スタティックメソッド(static method):
構造体そのものに関連づけられた関数。selfを引数に取らない
→コントラクタ関数などによく用いられる
→→型名::関数名()で参照する

コンストラクタをnew()にするのはRustの慣習

１つの型に対して複数のimplブロックを書くこともできる
→ただし全てのimplブロックは型を定義したのと同一crateに入っていないといけない

独自のメソッドを他の型につけることもできる
→詳しくは「11章 トレイトとジェネリクス」で

型定義とメソッド定義を分ける利点
・型のデータメンバを見つけるのが簡単
・タプル型やユニット型のメソッドも同形式で定義できる(同じ構文を基本型にも用いる)
・impl構文がトレイトの実装でも使える→11章

追記:引数に複数の生存期間が現れる場合でもself仮引数の生存期間を優先

9.6 ジェネリック構造体

Rustの構造体はジェネリック(generic)にすることができる

<T>は型パラメータ(type parameters)と呼ばれる

struct Name<T> P
    hoge: foo<T>,
    ...
}

impl<T> Name<T> {
   ...
}

関数のシグネチャと型宣言以外は型パラメータを推論してくれることが多い

staticメソッド呼び出し時はターボフィッシュ::<>を用いて明示的に型を与えられる
→実際は推論させることが多い

全てのimplブロックで特別な型パラメータSelfがメソッドを追加する対象の型として定義される

9.7 生存期間パラメータを持つ構造体

構造体型が参照を含むなら、参照の生存期間を指定する必要がある

suruct Name<'elt> {
    ...
}
→任意の生存期間'eltに対して、生存期間が'eltの参照を保持するName<'elt>を作ることができると言う意味

Rustは常に関数呼び出し時に生存期間パラメータを推論する
明らかな候補が1つしかないときは宣言時に省略できる
→参照を参照

9.8 一般的なトレイトの自動実装

トレイト:
型が実装することができるメソッドの集合

独自に定義した構造体は通常コピーもクローンはできない
→それ以外にも通常の操作で色々できないことがある
→→Copy, Clone, Debug, PartialEq
→→→11章で独自の方に対するトレイトの実装方法を説明する

#[derive(...)]で自動的に実装してくれる
→全てのフィールドがこれらのトレイトを実装していたら自動的に実装できる
→PartialOrdトレイトも自動実装可能である
→→明示的に書かせるのは、自動的に定義するのがふさわしくないことがあるから
→→また、トレイトを実装すると自動的にそのトレイトがpublicになってしまう
→→→標準トレイトとderive可能性については13章で

9.9 内部可変性

可変性は多すぎると面倒だが少しはないと困る

スマートポインタRc<T>
→参照カウント。Rcに収められている値は常に不変

内部可変性(interior mutability):
ほとんどの部分が不変な値でほんの少しだけ可変データを含む
→実装方法はいくつかある

例えば
・Cell<T>
・RefCell<T>
→std::cellモジュールに含まれる

Cell<T>構造体
→型Tのprivateな値を1つだけ持つ
→→Cellそのものに対するmutな参照を持ってなくてもフィールドを見たりセットしたりできる

Cell::new(value) :新しいCellを作りvalueを中に移動
cell.get()       :cellの中の値のcopyを返す
cell.set(value)  :与えられたvalueをcellの中にセットして以前の値をdropする
 →fn set(&self, value: T) // note: not `&mut self`
 →→もちろんこれは普通ではない。本来mutableな引数を与えられないと変化させられない

Cellの他のメソッドはドキュメント(https://doc.rust-lang.org/std/cell/struct.Cell.html)を参照
単純なカウンタを追加したりするのにも使える

Cellは共有されている変数に対してmutメソッドを呼ばせてくれない
.get()はCopyトレイトを実装したTにしか使えない

RefCell<T>構造体
→型Tの値を1つだけ持つジェネリック型
→→Cellとは違いT値への参照の借用をサポートしている

RefCell::new(value)   :新しいRefCellを作りvalueを中に移動
ref_cell.borrow()     :ref_cellに収められた値への共有参照をRef<T>として返す
 →値がすでに可変で借用されていた場合にはpanicを起こす
ref_cell.borrow_mut() :ref_cellに収められた値への可変参照をRefMut<T>として返す
 →値がすでに借用されていた場合にはpanicを起こす

RefCellの他のメソッドはドキュメントを参照

2つのborrowメソッドは「mut参照は排他的でなければならない」というルールを破るとpanic
→コンパイルは通ってしまう
→→実行時チェックで実現する

RefMut<T>型
→T型への可変参照と同じように扱える

セルの問題点
・.get()や.borrow_mut()などを呼び出さなければならない
・セルとそれを含む全ての型はスレッド安全ではない
 →複数のスレッドからセルにアクセスすることは許されない
 →→スレッド安全な内部可変性については19章で詳しく述べる

構造体はA and B and C and ...という風に値を集めたもの
次の章ではA or B or ...を扱う
