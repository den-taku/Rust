19章 並列性

イディオム

バックグラウンドスレッド:
1つだけ仕事があり定期的に起きてその仕事を行う

汎用ワーカプール:
クライアントとタスクキューで通信

パイプライン:
データはこれを通してあるスレッドから次のスレッドへと流れていく
個々のスレッドは仕事の一部を行う

データ並列:
計算をn個に分割してn個のスレッドを実行しn個の計算機コアが同時に動作することを期待

同期オブジェクトの海:
複数のスレッドが同じデータにアクセスすることが許されておりロックでデータ競合を回避する

アトミックな整数処理:
複数のコアが機械依存の1ワード長のfieldを通して通信を行う

Rustなら全てのプログラムを1つのスタイルに制限せずに並列性を利用することができる

Rustの安全で高速な並列プログラミング
→ここでは3つのスレッドの使い方が説明される

・フォーク・ジョイン並列
・チャネル
・可変状態の共有

19.1 フォーク・ジョイン並列

スレッドの最も簡単な使い方
→完全に独立した複数のタスクを一度に実行する方法

フォーク:
新しいスレッドを起動すること

ジョイン:
1つのスレッドが終了するのを待つこと

・非常に単純
・ボトルネックがない
・性能を計算するのが簡単(均等に分割できない/統合する時間が必要という点を除けば)
・プログラムの正しさを推測するのが容易(速度によらず結果が等しい)

19.1.1 spawnとjoin

関数std::thread::spawnは新しいスレッドを起動する

spawn(||{...})

FnOnceのクロージャもしくは関数を引数としてとる
→独自のスタックを持つOSのスレッド

仕事をいくつかのチャンクに分割
↓
フォーク:それぞれのチャンクを処理するスレッドを起動
↓
ジョイン:全てのスレッドが終了するのを待つ

spawn()はJoinHandleと呼ばれる値を返す

JoinHandle::join()で全てのスレッドが終了するのを待つ
→mainが終了すると他に走っているスレッドがあってもすぐに終了してしまうため

19.1.2 スレッド間でのエラー処理

.join()メソッドは2つのことをする

handle.join()はstd::thread::Resultを返す
→子スレッドがパニックを起こした場合エラーとなる
→→panicは安全でスレッド単位で起こる

handle.join()は子スレッドが返す値を親スレッドに返す
→std::thread::Result<...>を返す

他言語ではエラー処理を注意深く書かなくてはいけない
→Resultで処理できるRustは素晴らしい

19.1.3 不変データのスレッド間共有

子スレッドの生存期間は親スレッドより長くなる可能性がある
→アトミックな参照カウント
→.clone()でスマートポインタArcのコピーが作られるだけなので安価

19.1.4 Rayon

spawn関数を使って実装されたより良いフォーク・ジョインAPIがある

Crossbeamのスコープ付きスレッド

Rayon
→タスクを並列に実行する方法を2つ提供する

reyon::join(fn1, fn2):
2つの関数を呼び出し2つの結果を返す

.par_iter():
ParallelIterarorを作り出す
→Iteratorのようにmapやfilterなどのメソッドを持つ

いずれの場合も独自のワーカスレッドプールを使い可能な限り仕事をスレッドに分散する

Rayonはワークスティールと呼ばれる方法でスレッド間の負荷を調整している
→ベクタの各要素にスレッドを起動しているように書いても1コアにつき1ワークスレッドしか使っていない

さらにスレッド間での共有参照をサポートしている

19.1.5 マンデルブロ集合再訪

Rayonは仕事をワークスティールを使って効率的に分担する
→Crossbeamよりはやくなった

19.2 チャネル

























































































