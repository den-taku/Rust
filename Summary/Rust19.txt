19章 並列性

イディオム

バックグラウンドスレッド:
1つだけ仕事があり定期的に起きてその仕事を行う

汎用ワーカプール:
クライアントとタスクキューで通信

パイプライン:
データはこれを通してあるスレッドから次のスレッドへと流れていく
個々のスレッドは仕事の一部を行う

データ並列:
計算をn個に分割してn個のスレッドを実行しn個の計算機コアが同時に動作することを期待

同期オブジェクトの海:
複数のスレッドが同じデータにアクセスすることが許されておりロックでデータ競合を回避する

アトミックな整数処理:
複数のコアが機械依存の1ワード長のfieldを通して通信を行う

Rustなら全てのプログラムを1つのスタイルに制限せずに並列性を利用することができる

Rustの安全で高速な並列プログラミング
→ここでは3つのスレッドの使い方が説明される

・フォーク・ジョイン並列
・チャネル
・可変状態の共有

19.1 フォーク・ジョイン並列

スレッドの最も簡単な使い方
→完全に独立した複数のタスクを一度に実行する方法

フォーク:
新しいスレッドを起動すること

ジョイン:
1つのスレッドが終了するのを待つこと

・非常に単純
・ボトルネックがない
・性能を計算するのが簡単(均等に分割できない/統合する時間が必要という点を除けば)
・プログラムの正しさを推測するのが容易(速度によらず結果が等しい)

19.1.1 spawnとjoin

関数std::thread::spawnは新しいスレッドを起動する

spawn(||{...})

FnOnceのクロージャもしくは関数を引数としてとる
→独自のスタックを持つOSのスレッド

仕事をいくつかのチャンクに分割
↓
フォーク:それぞれのチャンクを処理するスレッドを起動
↓
ジョイン:全てのスレッドが終了するのを待つ

spawn()はJoinHandleと呼ばれる値を返す

JoinHandle::join()で全てのスレッドが終了するのを待つ
→mainが終了すると他に走っているスレッドがあってもすぐに終了してしまうため

19.1.2 スレッド間でのエラー処理

.join()メソッドは2つのことをする

handle.join()はstd::thread::Resultを返す
→子スレッドがパニックを起こした場合エラーとなる
→→panicは安全でスレッド単位で起こる

handle.join()は子スレッドが返す値を親スレッドに返す
→std::thread::Result<...>を返す

他言語ではエラー処理を注意深く書かなくてはいけない
→Resultで処理できるRustは素晴らしい

19.1.3 不変データのスレッド間共有

子スレッドの生存期間は親スレッドより長くなる可能性がある
→アトミックな参照カウント
→.clone()でスマートポインタArcのコピーが作られるだけなので安価

19.1.4 Rayon

spawn関数を使って実装されたより良いフォーク・ジョインAPIがある

Crossbeamのスコープ付きスレッド

Rayon
→タスクを並列に実行する方法を2つ提供する

reyon::join(fn1, fn2):
2つの関数を呼び出し2つの結果を返す

.par_iter():
ParallelIterarorを作り出す
→Iteratorのようにmapやfilterなどのメソッドを持つ

いずれの場合も独自のワーカスレッドプールを使い可能な限り仕事をスレッドに分散する

Rayonはワークスティールと呼ばれる方法でスレッド間の負荷を調整している
→ベクタの各要素にスレッドを起動しているように書いても1コアにつき1ワークスレッドしか使っていない

さらにスレッド間での共有参照をサポートしている

19.1.5 マンデルブロ集合再訪

Rayonは仕事をワークスティールを使って効率的に分担する
→Crossbeamよりはやくなった

19.2 チャネル

チャネル:
あるスレッドから別のスレッドに値を送信する一方通行のパイプ
→スレッド安全なキューだと考えても良い

通常、両端の所有者は別のスレッドになる
→sender.send(item)で値を1つチャネルにおく
→receiver.recv()で値を1つ取り除く

Rustのチャネルは値を移動する
→高速に動作する

19.2.1 値の送信

channelはstd::sync::mpscモジュールの一部

channel()は値のペア(sender, receiver)を返す
→それぞれ型はSender<T>、Receiver<T>になる

sendメソッドとrecvメソッドはResultを返す
→失敗するのはチャネルの相手がドロップされた時だけ

19.2.2 値の受信

受信時にチャネルが空
→他のスレッドが値を送ってくるまで待機する

19.2.3 パイプラインの実行

パイプラインの性能
→最も遅いステージのスループットに制約される

19.2.4 チャネルの機能と性能

std::sync::mpscのmpsc
→multi-producer, single-consumerを意味する

Rustのチャネルは複数の送信者もサポートしている
→Sender<T>はCloneトレイトを実装しているので、必要なだけSenderをクローンすれば良い
→→Receiver<T>はクローンできないのでMutexが必要になる

Rustのチャネルは適宜実装を切り替える
→速度が最速かつメモリ安全になるように最適化する

送信者が速すぎるとチャネルの性能が低下する
→バックプレッシャによって強制的に遅くする(個々のパイプに固定されたサイズが設定される)
→→このような機構は同期チャネルと呼ばれる(std::sync::mpsc::sync_channel)

sync_channel(32)のように上限値を設定してブロックする

19.2.5 スレッド安全性:SendとSync

完全なスレッド安全性を実現するトレイト
→std::marker::Sendとstd::marker::Sync

Send
→他のスレッドに値で渡しても安全

Sync
→他のスレッドに非mut参照で渡しても安全

ほとんどの型はSendでありSync
→独自の構造体や列挙型にこれらのトレイトを実装するのには宣言する必要さえない

データがスレッド間の境界を超えて転送されるときに制約としてSendやSyncが必要

19.2.6 ほとんどすべてのイテレータをつなげられるチャネル

言語に現れるほとんど全てのイテレータを並列で処理できる
→そのためには制約を理解し記述しなければならない

19.2.7 パイプラインを超えて

チャネルはパイプライン以外にも使うことができる
→例えば非同期サービスを同じプロセス上の他のスレッド群に提供できる

フォーク・ジョイン:高並列な計算
チャネル:緩やかに構成要素を結合

19.3 可変状態の共有

本節では排他ロック、リード/ライトロック、条件変数、アトミック整数について説明される
最後にグルーバルな可変変数をRustで実現する方法が示される

19.3.1 排他ロックとは何か？

排他ロック(もしくは単にロック)
→複数のスレッドがあるデータに同時にはアクセスできないようにする

・データ競合を防ぐ
・読み出しと書き込み動作の順序が予測可能になる
・不変条件(invariant)を用いたプログラミングをサポート

他言語ではコンパイラで安全なアクセスを強制することはできない

19.3.1 Mutex<T>












































































