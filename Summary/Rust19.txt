19章 並列性

イディオム

バックグラウンドスレッド:
1つだけ仕事があり定期的に起きてその仕事を行う

汎用ワーカプール:
クライアントとタスクキューで通信

パイプライン:
データはこれを通してあるスレッドから次のスレッドへと流れていく
個々のスレッドは仕事の一部を行う

データ並列:
計算をn個に分割してn個のスレッドを実行しn個の計算機コアが同時に動作することを期待

同期オブジェクトの海:
複数のスレッドが同じデータにアクセスすることが許されておりロックでデータ競合を回避する

アトミックな整数処理:
複数のコアが機械依存の1ワード長のfieldを通して通信を行う

Rustなら全てのプログラムを1つのスタイルに制限せずに並列性を利用することができる

Rustの安全で高速な並列プログラミング
→ここでは3つのスレッドの使い方が説明される

・フォーク・ジョイン並列
・チャネル
・可変状態の共有

19.1 フォーク・ジョイン並列

スレッドの最も簡単な使い方
→完全に独立した複数のタスクを一度に実行する方法

フォーク:
新しいスレッドを起動すること

ジョイン:
1つのスレッドが終了するのを待つこと

・非常に単純
・ボトルネックがない
・性能を計算するのが簡単(均等に分割できない/統合する時間が必要という点を除けば)
・プログラムの正しさを推測するのが容易(速度によらず結果が等しい)

19.1.1 spawnとjoin

関数std::thread::spawnは新しいスレッドを起動する

spawn(||{...})

FnOnceのクロージャもしくは関数を引数としてとる
→独自のスタックを持つOSのスレッド

仕事をいくつかのチャンクに分割
↓
フォーク:それぞれのチャンクを処理するスレッドを起動
↓
ジョイン:全てのスレッドが終了するのを待つ

spawn()はJoinHandleと呼ばれる値を返す

JoinHandle::join()で全てのスレッドが終了するのを待つ
→mainが終了すると他に走っているスレッドがあってもすぐに終了してしまうため

19.1.2 スレッド間でのエラー処理

.join()メソッドは2つのことをする

handle.join()はstd::thread::Resultを返す
→子スレッドがパニックを起こした場合エラーとなる
→→panicは安全でスレッド単位で起こる

handle.join()は子スレッドが返す値を親スレッドに返す
→std::thread::Result<...>を返す

他言語ではエラー処理を注意深く書かなくてはいけない
→Resultで処理できるRustは素晴らしい

19.1.3 不変データのスレッド間共有

子スレッドの生存期間は親スレッドより長くなる可能性がある
→アトミックな参照カウント
→.clone()でスマートポインタArcのコピーが作られるだけなので安価

19.1.4 Rayon

spawn関数を使って実装されたより良いフォーク・ジョインAPIがある

Crossbeamのスコープ付きスレッド

Rayon
→タスクを並列に実行する方法を2つ提供する

reyon::join(fn1, fn2):
2つの関数を呼び出し2つの結果を返す

.par_iter():
ParallelIterarorを作り出す
→Iteratorのようにmapやfilterなどのメソッドを持つ

いずれの場合も独自のワーカスレッドプールを使い可能な限り仕事をスレッドに分散する

Rayonはワークスティールと呼ばれる方法でスレッド間の負荷を調整している
→ベクタの各要素にスレッドを起動しているように書いても1コアにつき1ワークスレッドしか使っていない

さらにスレッド間での共有参照をサポートしている

19.1.5 マンデルブロ集合再訪

Rayonは仕事をワークスティールを使って効率的に分担する
→Crossbeamよりはやくなった

19.2 チャネル

チャネル:
あるスレッドから別のスレッドに値を送信する一方通行のパイプ
→スレッド安全なキューだと考えても良い

通常、両端の所有者は別のスレッドになる
→sender.send(item)で値を1つチャネルにおく
→receiver.recv()で値を1つ取り除く

Rustのチャネルは値を移動する
→高速に動作する

19.2.1 値の送信

channelはstd::sync::mpscモジュールの一部

channel()は値のペア(sender, receiver)を返す
→それぞれ型はSender<T>、Receiver<T>になる

sendメソッドとrecvメソッドはResultを返す
→失敗するのはチャネルの相手がドロップされた時だけ

19.2.2 値の受信

受信時にチャネルが空
→他のスレッドが値を送ってくるまで待機する

19.2.3 パイプラインの実行

パイプラインの性能
→最も遅いステージのスループットに制約される

19.2.4 チャネルの機能と性能

std::sync::mpscのmpsc
→multi-producer, single-consumerを意味する

Rustのチャネルは複数の送信者もサポートしている
→Sender<T>はCloneトレイトを実装しているので、必要なだけSenderをクローンすれば良い
→→Receiver<T>はクローンできないのでMutexが必要になる

Rustのチャネルは適宜実装を切り替える
→速度が最速かつメモリ安全になるように最適化する

送信者が速すぎるとチャネルの性能が低下する
→バックプレッシャによって強制的に遅くする(個々のパイプに固定されたサイズが設定される)
→→このような機構は同期チャネルと呼ばれる(std::sync::mpsc::sync_channel)

sync_channel(32)のように上限値を設定してブロックする

19.2.5 スレッド安全性:SendとSync

完全なスレッド安全性を実現するトレイト
→std::marker::Sendとstd::marker::Sync

Send
→他のスレッドに値で渡しても安全

Sync
→他のスレッドに非mut参照で渡しても安全

ほとんどの型はSendでありSync
→独自の構造体や列挙型にこれらのトレイトを実装するのには宣言する必要さえない

データがスレッド間の境界を超えて転送されるときに制約としてSendやSyncが必要

19.2.6 ほとんどすべてのイテレータをつなげられるチャネル

言語に現れるほとんど全てのイテレータを並列で処理できる
→そのためには制約を理解し記述しなければならない

19.2.7 パイプラインを超えて

チャネルはパイプライン以外にも使うことができる
→例えば非同期サービスを同じプロセス上の他のスレッド群に提供できる

フォーク・ジョイン:高並列な計算
チャネル:緩やかに構成要素を結合

19.3 可変状態の共有

本節では排他ロック、リード/ライトロック、条件変数、アトミック整数について説明される
最後にグルーバルな可変変数をRustで実現する方法が示される

19.3.1 排他ロックとは何か？

排他ロック(もしくは単にロック)
→複数のスレッドがあるデータに同時にはアクセスできないようにする

・データ競合を防ぐ
・読み出しと書き込み動作の順序が予測可能になる
・不変条件(invariant)を用いたプログラミングをサポート

他言語ではコンパイラで安全なアクセスを強制することはできない

19.3.2 Mutex<T>

守る対象のデータをMutexの内部に格納する

Arc
→スレッド間で何かを共有する際に有用

Mutex
→複数のスレッドから共有アクセスされる可変データを表すのに有用

データにアクセスするには.lock()メソッドを呼ぶ
→返されるMutexGuard<T>はDerefMutトレイトのおかげで&mut Tと等価に扱える
→→ガードの内部データへの直接の参照も生存期間の制約のおかげで安全に利用可能
→→返された値がdropされるとロックは解放される(drop()で明示的に解放しても良い)

19.3.3 可変性とMutex

mut参照は排他アクセスを意味する
非mut参照は共有アクセスを意味する

Mutexはロックによって排他アクセスが保証される
→Mutexそのものに対しては複数スレッドが共有アクセス権限を持ちつつ内部データに対しては排他アクセスを提供できる

Mutexは通常コンパイラによって静的に行われる排他アクセスの強制を動的に行う

19.3.4 排他ロックがいつもいいとは限らないのはなぜか

安全なRustコードはデータ競合を起こさない

排他ロックを使うスレッドには他にも問題が起こりうる

・プログラムの動作がスレッドのタイミングに依存し実行するたびに結果が異なるという競合状態
・可変状態の共有はプログラムの設計に影響する(テストが難しい)
・そもそも単純ではない

→可能な限りより構造化された手法を使うべき

19.3.5 デッドロック

既に保有しているロックを再度取りに行くとデッドロックする
→他にも複数のスレッドが複数の排他ロックを同時に取ろうとしたときにも起こりうる

Rustの借用システムではデッドロックを防ぐことができない
→最良の方法はクリティカルセクションを小さく保つこと

チャネルでデッドロックを起こすこともできる

19.3.6 毒された排他ロック

Mutex::lock()はResultを返す

Mutexを保持したスレッドがパニックを起こす
→そのMutexを毒されたものとしてマークする
→→毒されたMutexへのそれ以降のlockはエラーになる

パニックが起きた場合、フィールドの更新が担保されない
→不変条件を満たし得ないので他のスレッドから触れないようにする

毒された排他ロックでも内部データに排他的にアクセスすることができる
→詳しくはPoisonError::into_inner()のドキュメントを見るべし

19.3.7 排他ロックを用いた、複数の消費者を持つチャネル

チャネルのReceiverは1つしか作れない
→MutexでReceiverを包んで共有すれば良い
→→実装はChapter19/mc

19.3.8 レードライトロック(RwLock<T>)

標準ライブラリツールキットstd::sync
→スレッド同期ツールを提供する

排他ロックで書くと不要なボトルネックになる
→リードライトロックもしくはRwLockを使う

リードライトロックには2つのロックメソッドがある
→readとwrite

RwLock::writeメソッド:
守られているデータに対する排他的なmutアクセスが取得できるまで待つ
→クリティカルセクション中はリーダもライタも1つしか持てない

RwLock::readメソッド:
非mutアクセスを提供する

19.3.9 条件変数(Condvar)

ある条件が満たされるまでスレッドが待機しなくてはならない場合がある
→ブロッキングAPIがないなら条件変数を用いて作ることになる

条件変数
→特定のMutexで守られたデータに関する特定の真偽状態に対するもの

条件が満たされるとCondvar::notify_all(もしくはnotity_one)を呼び出してスレッドを起動する
待機するにはCondvar::wait()を用いる(whileループ中で)

19.3.10 アトミック変数

std::sync::atomicモジュール
→ロックフリー並列プログラムのためのアトミックな型が含まれている

AtomicIsize、AatomicUsize:
共有される整数型。シングルスレッドのisize、usizeに該当

AtomicBool:
共有されるbool値

AtomicPtr<T>:
共有される安全でないポインタ型*mut T

アトミックな値:
複数のスレッドが同時に読み書きしてもデータ競合が発生しない

アトミックな型
→アトミックな操作を行うメソッドを提供している
→→ロード、ストア、交換、数値演算などで他のスレッドから同時にアクセスしても安全
→→→特殊な機械語命令にコンパイルされる

メモリ順序を指定する
→性能ペナルティはそれほど発生しない

アトミックは内部可変性の1つの形

19.3.11 グローバル変数

Rustはグローバルな可変状態を使わせないようにする

スレッド安全を保ちながら可変にするにはアトミック整数にするのが簡単
→static変数の初期値は定数である必要があるのでATOMIC_USIZE_INITなどを使う

アトミックなグローバル変数は単純な型だけ
→他の型で表現するときは2つの問題を解決する必要がある

・変数はスレッド安全でなければならない。static変数はSyncで非mut(Mutexなどを使えば良い)
・static変数の初期化には関数を呼べない(lazy_staticクレートで回避できる)

lazy_static!
→staticデータにアクセスするたびに性能上のコストが少しずつかかる
→→一度だけの初期化のための低レベルな同期プリミティブstd::sync::Onceで実装されている

19.4 Rustでの並列コードの開発





























































