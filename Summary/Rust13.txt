13章 ユーティリティトレイト

演算子オーバーロード以外にも組み込みトレイトを使って機能をフックできる

本章はRustのstdライブラリで提供される有用なトレイトを紹介
→トレイト各種はp.273など

13.1 Drop

値をdropする時は色々解放しなければならない

式の値が;演算子で捨てられた時などにもdropは発生する

ほとんどの場合においてRustは自動的にdropしてくれる

std::ops::Dropトレイトを実装
→独自型の値がdropされる時の動作をカスタマイズできる

値がdropされる時std::ops::Dropを実装していたら、各データをdropする前にdropメソッドを呼ぶ
→dropメソッドはこの暗黙の呼び出し以外で呼び出せない
→→Drop::dropが受け取る値は完全に値が入った状態になる

trait Drop {
    fn drop(&mut self);
}

値そのものの解放
→VecやString、変数などが請け負う

変数のスコープが終わるときに未初期化
→その変数をドロップしようとしない
→→制御フローによって値が移動されているかわからないときも適用される
→→→変数の状態を見えないフラグとして保持してドロップする必要があるかを管理

Rustが知らない資源を管理する型を定義しているのでもない限りDropを実装する必要はない

ある型がDropトレイトを実装
→その方はCopyトレイトを実装できない
→→同じデータに対して2回以上dropが呼び出されるのはあまりよくない

標準プレリュードのdropは単純(何もしない)
fn drop<T>(_x: T) {}

13.2 Sized






























































































